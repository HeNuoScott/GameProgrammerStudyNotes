# Game Programming Patterns 游戏编程模式
Unity实现《游戏编程模式》

# 重访设计模式
## 命令模式

### 定义

将一个请求封装为**一个对象**，从而使你可用不同的请求对客户进行参数化； 对请求排队或记录请求日志，以及支持可**撤销**的操作。

### 场景

1. 通过操作来参数化对象
2. 将操作放入队列中、操作的执行或者远程执行操作
3. 实现操作回滚功能

### 案例

1. **[配置输入](./Assets/DesignPatternsRevisited/CommandPattern)**：用户通过键盘、手柄以及界面按钮实现移动等操作，并可以实现撤销操作；
2. GUI中的点击等UI操作，即**交互逻辑**应该可以通过命令模式来实现具体的业务逻辑，从而进行逻辑解耦；数值更新的**表现逻辑**，可以通过**观察者模式**进行逻辑解耦*(事件的方式，进行通知)*；

### 实现方式

1. 声明仅有一个执行方法的[命令接口](./Assets/DesignPatternsRevisited/CommandPattern/Command.cs)。
2. 抽取请求并使之成为实现命令接口的[具体命令类](./Assets/DesignPatternsRevisited/CommandPattern/MoveCommand.cs)。 每个类都必须有一组成员变量来保存请求参数和对于实际接收者对象的引用。 所有这些变量的数值都必须通过命令构造函数进行初始化。
3. 找到担任[*发送者*职责的类](./Assets/DesignPatternsRevisited/CommandPattern/InputHandler.cs)。 在这些类中添加保存命令的成员变量。 发送者只能通过命令接口与其命令进行交互。 发送者自身通常并不创建命令对象， 而是通过客户端代码获取。
4. 修改发送者使其执行命令， 而非直接将请求发送给接收者。
5. 客户端必须按照以下顺序来初始化对象：
   - 创建接收者。
   - 创建命令， 如有需要可将其关联至接收者。
   - 创建发送者并将其与特定命令关联。

### 优缺点

**优点**

-  *单一职责原则*。 你可以解耦[触发](./Assets/DesignPatternsRevisited/CommandPattern/MoveCommand.cs)和[执行](./Assets/DesignPatternsRevisited/CommandPattern/MoveCommandReceiver.cs)操作的类。

-  *开闭原则*。 你可以在不修改已有客户端代码的情况下在程序中创建新的命令。

-  你可以实现撤销和恢复功能。

-  你可以实现操作的延迟执行。

-  你可以将一组简单命令组合成一个复杂命令。

- 运行时切换连接至发送者的命令对象， 以此改变发送者的行为。

  ```c#
  MoveCommand moveCommand = new MoveCommand(moveCommandReciever, direction, moveDistance, objectToMove);
  JumpCommand jumpCommand = new JumpCommand(jumpCommandReciever, direction, jumpDistance, objectToMove);
  Command command;
  if (isMove){
      command = moveCommand；
  } else {
      command = jumpCommand；
  }
  command.Execute();
  ```

**缺点**

* 代码可能会变得更加复杂， 因为你在发送者和接收者之间增加了一个全新的层次。*(全新层次指本来只需要直接调用方法来实现操作就可以，现在需要通过命令类来实现操作)*

### 与其他设计模式的关系

- 责任链模式***(GOF)*、 命令模式、 中介者模式** *(GOF)*和观察者模式用于处理请求发送者和接收者之间的不同连接方式：

  - *责任链*按照顺序将请求动态传递给**一系列**的潜在接收者， 直至其中一名接收者对请求进行处理。
  - *命令*在发送者和请求者之间建立**单向连接**。
  - *中介者*清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行**间接沟通(双向)**。
  - *观察者*允许接收者动态地**订阅或取消**接收请求。

- 责任链的管理者可使用命令模式实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。

  还有另外一种实现方式， 那就是请求自身就是一个*命令*对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。

- 你可以同时使用**命令**和**备忘录模式** *(GOF)*来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态。

- 命令和策略模式看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。

  - 你可以使用*命令*来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。
  - 另一方面， *策略*通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。

- 原型模式可用于保存命令的历史记录。

- 你可以将访问者模式视为命令模式的加强版本， 其对象可对不同类的多种对象执行操作。

## 享元模式

### 定义

摒弃了在每个对象中保存所有数据的方式， 通过**共享**多个对象所共有的相同状态， 让你能在有限的内存容量中**载入更多对象**。

### 场景

1. 仅在程序必须支持**大量对象**且没有足够的内存容量时

### 案例

**[字符对象](./Assets/DesignPatternsRevisited/FlyweightPattern)**：A-Z每个字符作为一个对象，所有的A，有着相同的属性(内在属性)，例如：width、height等；也有着不同的属性(外在属性)，例如：pointSize

### 实现方式

1. 将需要改写为享元的类成员变量拆分为两个部分：
   - 内在状态： 包含不变的、 可在许多对象中重复使用的数据的成员变量。
   - 外在状态： 包含每个对象各自不同的情景数据的成员变量
2. 保留类中表示内在状态的成员变量， 并将其属性设置为不可修改。 这些变量仅可在构造函数中获得初始数值。
3. 找到所有使用外在状态成员变量的方法， 为在方法中所用的每个成员变量新建一个参数， 并使用该参数代替成员变量。
4. 你可以有选择地创建工厂类来管理享元缓存池， 它负责在新建享元时检查已有的享元。 如果选择使用工厂， 客户端就只能通过工厂来请求享元， 它们需要将享元的内在状态作为参数传递给工厂。
5. 客户端必须存储和计算外在状态 （情景） 的数值， 因为只有这样才能调用享元对象的方法。 为了使用方便， 外在状态和引用享元的成员变量可以移动到单独的情景类中。

### 优缺点

**优点**

-  如果程序中有很多相似对象， 那么你将可以节省大量内存。


**缺点**

*  你可能需要牺牲执行速度来换取内存， 因为他人每次调用享元方法时都需要重新计算部分情景数据。
*  代码会变得更加复杂。 团队中的新成员总是会问：  “为什么要像这样拆分一个实体的状态？”。

### 与其他设计模式的关系

- 你可以使用**享元模式**实现**组合模式***(GOF)*树的共享叶节点以节省内存。

- 享元展示了如何生成大量的小型对象， **外观模式*****(GOF)*则展示了如何用一个对象来代表整个子系统。
- 如果你能将对象的所有共享状态简化为一个享元对象， 那么**享元**就和**单例模式**类似了。 但这两个模式有两个根本性的不同。
  1. 只会有一个单例实体， 但是*享元*类可以有多个实体， 各实体的内在状态也可以不同。
  2. *单例*对象可以是可变的。 享元对象是不可变的。

## 观察者模式

### 定义

允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。

### 场景

1. **当一个对象状态的改变需要改变其他对象****，** **或实际对象是事先未知的或动态变化的时**
2.  **当应用中的一些对象必须观察其他对象时****，** **可使用该模式****。** **但仅能在有限时间内或特定情况下使用**

### 案例

1. [消息系统](./Assets/DesignPatternsRevisited/ObserverPattern)
2. 数据绑定

### 实现方式

1. 仔细检查你的业务逻辑， 试着将其拆分为两个部分： 独立于其他代码的核心功能将作为发布者； 其他代码则将转化为一组订阅类。

2. 声明订阅者接口。 该接口至少应声明一个 `update`方法。

3. 声明发布者接口并定义一些接口来在列表中添加和删除订阅对象。 记住发布者必须仅通过订阅者接口与它们进行交互。

4. 确定存放实际订阅列表的位置并实现订阅方法。 通常所有类型的发布者代码看上去都一样， 因此将列表放置在直接扩展自发布者接口的抽象类中是显而易见的。 具体发布者会扩展该类从而继承所有的订阅行为。

   但是， 如果你需要在现有的类层次结构中应用该模式， 则可以考虑使用组合的方式： 将订阅逻辑放入一个独立的对象， 然后让所有实际订阅者使用该对象。

5. 创建具体发布者类。 每次发布者发生了重要事件时都必须通知所有的订阅者。

6. 在具体订阅者类中实现通知更新的方法。 绝大部分订阅者需要一些与事件相关的上下文数据。 这些数据可作为通知方法的参数来传递。

   但还有另一种选择。 订阅者接收到通知后直接从通知中获取所有数据。 在这种情况下， 发布者必须通过更新方法将自身传递出去。 另一种不太灵活的方式是通过构造函数将发布者与订阅者永久性地连接起来。

7. 客户端必须生成所需的全部订阅者， 并在相应的发布者处完成注册工作。

### 优缺点

**优点**

-  *开闭原则*。 你无需修改发布者代码就能引入新的订阅者类 （如果是发布者接口则可轻松引入发布者类）。
-  你可以在运行时建立对象之间的联系。

**缺点**

-  订阅者的通知顺序是随机的。

### 与其他设计模式的关系

- **责任链模式** * *(GOF)*、 **命令模式**、 **中介者模式**(GOF)*和观察者模式用于处理请求发送者和接收者之间的不同连接方式：

  - *责任链*按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。
  - *命令*在发送者和请求者之间建立单向连接。
  - *中介者*清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。
  - *观察者*允许接收者动态地订阅或取消接收请求。

- **中介者** *(GOF)*和**观察者**之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。

  *中介者*的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 *观察者*的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。

  有一种流行的中介者模式实现方式依赖于*观察者*。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当*中介者*以这种方式实现时， 它可能看上去与*观察者*非常相似。

  当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和*观察者*并不相同， 但这仍是一种中介者模式。

  假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。

## 原型模式

### 定义

使用特定原型实例来创建特定种类的对象，并且通过**拷贝**原型来创建新的对象

### 场景

1. 你需要复制一些对象，同时又希望代码独立于这些对象所属的具体类
2. 子类的区别仅在于其对象的初始化方式，那么你可以使用该模式来减少子类的数量。别人创建这些子类的目的可能是为了创建特定类型的对象。

### 案例

[克隆对象](./Assets/DesignPatternsRevisited/PrototypePattern)

### 实现方式

1. 创建原型接口， 并在其中声明 `克隆`方法。 如果你已有类层次结构， 则只需在其所有类中添加该方法即可。

2. 原型类必须另行定义一个以该类对象为参数的构造函数。 构造函数必须复制参数对象中的所有成员变量值到新建实体中。 如果你需要修改子类， 则必须调用父类构造函数， 让父类复制其私有成员变量值。

   如果编程语言不支持方法重载， 那么你可能需要定义一个特殊方法来复制对象数据。 在构造函数中进行此类处理比较方便， 因为它在调用 `new`运算符后会马上返回结果对象。

3. 克隆方法通常只有一行代码： 使用 `new`运算符调用原型版本的构造函数。 注意， 每个类都必须显式重写克隆方法并使用自身类名调用 `new`运算符。 否则， 克隆方法可能会生成父类的对象。

4. 你还可以创建一个中心化原型注册表， 用于存储常用原型。

   你可以新建一个工厂类来实现注册表， 或者在原型基类中添加一个获取原型的静态方法。 该方法必须能够根据客户端代码设定的条件进行搜索。 搜索条件可以是简单的字符串， 或者是一组复杂的搜索参数。 找到合适的原型后， 注册表应对原型进行克隆， 并将复制生成的对象返回给客户端。

   最后还要将对子类构造函数的直接调用替换为对原型注册表工厂方法的调用。

### 优缺点

**优点**

- 你可以克隆对象， 而无需与它们所属的具体类相耦合。
-  你可以克隆预生成原型， 避免反复运行初始化代码。
-  你可以更方便地生成复杂对象。
-  你可以用继承以外的方式来处理复杂对象的不同配置。

**缺点**

* 克隆包含循环引用的复杂对象可能会非常麻烦。

### 与其他设计模式的关系

## 单例模式

### 定义

### 场景

### 案例

### 实现方式

### 优缺点

**优点**

**缺点**

### 与其他设计模式的关系

## 状态模式

### 定义

### 场景

### 案例

### 实现方式

### 优缺点

**优点**

**缺点**

### 与其他设计模式的关系

# 序列模式
## 双缓冲模式

### 定义

### 场景

### 案例

### 实现方式

### 优缺点

**优点**

**缺点**

### 与其他设计模式的关系

## 游戏循环

### 定义

### 场景

### 案例

### 实现方式

### 优缺点

**优点**

**缺点**

### 与其他设计模式的关系

## 更新方法

### 定义

### 场景

### 案例

### 实现方式

### 优缺点

**优点**

**缺点**

### 与其他设计模式的关系

# 行为模式
## 字节码

### 定义

### 场景

### 案例

### 实现方式

### 优缺点

**优点**

**缺点**

### 与其他设计模式的关系

## 子类沙箱

### 定义

### 场景

### 案例

### 实现方式

### 优缺点

**优点**

**缺点**

### 与其他设计模式的关系

## 类型对象

### 定义

### 场景

### 案例

### 实现方式

### 优缺点

**优点**

**缺点**

### 与其他设计模式的关系

# 解耦模式
## 组件模式

### 定义

### 场景

### 案例

### 实现方式

### 优缺点

**优点**

**缺点**

### 与其他设计模式的关系

## 事件队列

### 定义

### 场景

### 案例

### 实现方式

### 优缺点

**优点**

**缺点**

### 与其他设计模式的关系

## 服务定位器

### 定义

### 场景

### 案例

### 实现方式

### 优缺点

**优点**

**缺点**

### 与其他设计模式的关系

# 优化模式
## 数据局部性

### 定义

### 场景

### 案例

### 实现方式

### 优缺点

**优点**

**缺点**

### 与其他设计模式的关系

## 脏标识模式

### 定义

### 场景

### 案例

### 实现方式

### 优缺点

**优点**

**缺点**

### 与其他设计模式的关系

## 对象池模式

### 定义

### 场景

### 案例

### 实现方式

### 优缺点

**优点**

**缺点**

### 与其他设计模式的关系

## 空间分区

### 定义

### 场景

### 案例

### 实现方式

### 优缺点

**优点**

**缺点**

### 与其他设计模式的关系

