## 类型对象

### 定义

创造一个类A来允许灵活地创造新“类型”，类A的每个实例都代表了不同的对象类型。

### 场景

- 你不知道你后面还需要什么类型。（举个例子，如果你的游戏需要支持资料包，而资料包有新的怪物品种呢？）
- 想不改变代码或者重新编译就能修改或添加新类型，即达到子类的名字、基本属性都是可以通过Json配置的目的

### 案例

[多类型的怪物](./Assets/BehavioralPatterns/TypeObject)

### 实现方式

* 定义**类型对象**类和**有类型的对象**类。

* 每个类型对象实例代表一种不同的逻辑类型。 

* 每种有类型的对象保存**对描述它类型的类型对象的引用**。

* 实例相关的数据被存储在有类型对象的实例中，被同种类分享的数据或者行为存储在类型对象中。 

* 引用同一类型对象的对象将会像同一类型一样运作。 

*这让我们在一组相同的对象间分享行为和数据，就像子类让我们做的那样，但没有固定的硬编码子类集合。*

### 优缺点

**优点**

* 可以快速、便捷的添加新的类型

**缺点**

* 更难为每种类型定义行为
* 需要手动追踪类型对象

### 与其他设计模式的关系

- 这个模式处理的高层问题是在多个对象间分享数据和行为。 另一个用另一种方式解决了相同问题的模式是**原型模式**。

- 类型对象是**享元模式**的近亲。 两者都让你在实例间**分享代码**。使用享元，意图是**节约内存**，而分享的数据也许不代表任何概念上对象的“类型”。 使用类型对象模式，焦点在组织性和灵活性。

- 这个模式和**状态模式**有很多相似之处。 两者都**委托对象的部分定义给另外一个对象**。 通过**类型对象**，我们通常委托了对象*是*什么：不变的数据概括描述对象。 通过**状态**，我们委托了对象*现在是什么*：暂时描述对象当前状态的数据。

  当我们讨论对象改变它的类型时，你可以认为类型对象起到了和状态相似的职责。