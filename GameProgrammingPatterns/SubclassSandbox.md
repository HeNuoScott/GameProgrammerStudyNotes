## 子类沙箱

### 定义

用一系列由基类提供的操作定义子类中的行为。

### 场景

- 你有一个能推导很多子类的基类。
- 基类可以提供子类需要的所有操作。
- 在子类中有行为重复，你想要更容易地在它们间分享代码。
- 你想要最小化子类和程序的其他部分的耦合。

### 案例

[超级英雄](./Assets/BehavioralPatterns/SubclassSandbox)

### 实现方式

* **基类**定义抽象的**沙箱方法**和几个**提供的操作**。

* 将操作标为protected，表明它们只为子类所使用。

* 每个推导出的**沙箱子类**用提供的操作实现了沙箱函数。

### 优缺点

**优点**

* 通过超级父类可以快速构建只有部分功能的子类

**缺点**

* 会有很多冗余代码。
* 游戏引擎中的每一部分都会与这些类耦合。
* 当外部代码需要改变时，一些随机超能力代码有很大几率会损坏。

### 与其他设计模式的关系

- 当你使用**更新模式**时，你的更新函数通常也是沙箱方法。
- 这个模式与**模板方法** *(GOF)*正相反。 两种模式中，都使用一系列受限操作实现方法。 使用子类沙箱时，方法在推导类中，受限操作在基类中。 使用模板方法时，*基类* 有方法，而受限操作在*推导*类中。
- 你也可以认为这个模式是**外观模式**  *(GOF)*的变形。 外观模式将一系列不同系统藏在简化的API后。使用子类沙箱，基类起到了在子类前隐藏整个游戏引擎的作用。