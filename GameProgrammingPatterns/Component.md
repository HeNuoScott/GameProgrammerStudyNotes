## 组件模式

### 定义

允许一个单一的实体跨越多个不同域而不会导致耦合。

### 场景

- 你有一个涉及多个域的类，但是你希望这些域保持相互解耦。
- 一个类越来越庞大，越来越难以开发。
- 你希望定义许多共享不同能力的对象，但采用继承的办法却无法令你精确地重用代码。

### 案例

[RPG游戏](./Assets/DecouplingPatterns/Component)

### 实现方式

* 单一实体跨越了多个领域。

* 为了保持领域之间相互分离，将每部分代码放入**各自的组件类**中。

* 实体被简化为*组件的容器*。

### 优缺点

**优点**

* 各个功能模块进行解耦

**缺点**

* 增加了组件之间的通信开销

### 与其他设计模式的关系

- 这种模式与GoF的策略模式类似。 两种模式都是将对象的行为取出，划入单独的重述对象。 与对象模式不同的是，分离的策略模式通常是无状态的——它封装了算法，而没有数据。 它定义了对象*如何*行动，但没有定义对象*是*什么。

  组件更加重要。它们经常保存了对象的状态，这有助于确定其真正的身份。 但是，这条界限很模糊。有一些组件也许根本没有任何状态。 在这种情况下，你可以在不同的容器对象中使用相同的组件*实例*。这样看来，它的行为确实更像一种策略。