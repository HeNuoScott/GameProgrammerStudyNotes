# Game Programming Patterns 游戏编程模式
Unity实现《游戏编程模式》

# 解耦模式
- 

- 

## 服务定位器

### 定义

提供服务的全局接入点，避免使用者和实现服务的具体类耦合。

### 场景

* 全局只有一个；建议和单例一样少用

### 案例

[全局声音管理](./Assets/DecouplingPatterns/ServiceLocator)

### 实现方式

* **服务** 类定义了一堆操作的抽象接口。

* 具体的**服务提供者**实现这个接口。 

* 分离的**服务定位器**提供了通过查询获取服务的方法，同时隐藏了服务提供者的具体细节和定位它的过程。

### 优缺点

**优点**

-  你可以保证一个类只有一个实例。
-  你获得了一个指向该实例的全局访问节点。
-  仅在首次请求对象时对其进行初始化。

**缺点**

-  违反了_单一职责原则_。 该模式同时解决了两个问题*(在一个方法中进行了创建类和提供类对象的操作)*。
-  单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。
-  该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。
-  客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用此模式。

### 与其他设计模式的关系

- **服务定位模式**在很多方面是**单例模式**的兄弟，在应用前值得看看哪个更适合你的需求。

# 优化模式
## 数据局部性

### 定义

合理组织数据，充分使用CPU的缓存来加速内存读取

### 场景

1. 性能问题确实由缓存不命中引起

### 案例

[更新大量相同组件](./Assets/OptimizationPatterns/DataLocality)

### 实现方式

* 现代的CPU有**缓存来加速内存读取**。

* 它可以**更快地读取最近访问过的内存的毗邻内存**。 

* 通过**提高内存局部性**来提高性能——保证数据**以处理顺序排列在连续内存上**。

### 优缺点

**优点**

1. 提高缓存利用率
2. 加快数据读写速度

**缺点**

* 系统更加复杂，更加缺乏灵活性

### 与其他设计模式的关系

- 这一模式几乎完全得益于同类对象的连续存储数组。 随着时间的推移，你也许需要向那个数组增加或删除对象。 **对象池模式**正是关于这一点。
- 这一章大部分围绕着**组件模式**。 这种模式的数据结构绝对是为缓存优化的最常见例子。事实上，使用组件模式让这种优化变得容易了。 由于实体是按“领域”（AI，物理，等等）更新的，将它们划出去变成组件，更容易将它们保存为对缓存友好的合适大小。但是这不意味你*只能*为组件使用这个模式！ 任何需要接触很多数据的关键代码，考虑数据局部性都是很重要的。

## 脏标识模式

### 定义

将工作延期至需要其结果时才去执行，避免不必要的工作

### 场景

- 原始数据的变化速度远高于导出数据的使用速度。 
- 增量更新十分困难。

### 案例

[渲染](./Assets/OptimizationPatterns/DirtyFlag)

### 实现方式

* 一组**原始数据**随着时间变化而改变。 
* 使用**代价昂贵的过程**推定一组**导出数据**。 
* 用一个**“脏”标识**追踪导出数据是否与原始数据保持一致。 
* 它在**原始数据改变时被设置。** 如果导出数据被请求时，该标识被设置了，那么**重新计算并清除标识** 否则的话，使用之前**缓存的导出数据**。

### 优缺点

**优点**

* 降低不必要的计算量

**缺点**

* 增加了系统复杂度

### 与其他设计模式的关系

独立的设计模式

## 对象池模式

### 定义

放弃单独地分配和释放对象，从固定的池中重用对象，以提高性能和内存使用率

### 场景

- 需要频繁创建和销毁对象。
- 对象大小相仿。
- 在堆上进行对象内存分配十分缓慢或者会导致内存碎片。
- 每个对象都封装了像数据库或者网络连接这样很昂贵又可以重用的资源。

### 案例

[对象池](./Assets/OptimizationPatterns/ObjectPool)

### 实现方式

* 定义一个**池**对象，其包含了一组**可重用对象**。
* 其中每个可重用对象都支持**查询“使用中”状态**，说明它是不是“正在使用”。
* 池被初始化时，它就创建了整个对象集合（通常使用一次连续的分配），然后初始化所有对象到“不在使用中”状态。
* 当你需要新对象，向池子要一个。 
* 它找到一个可用对象，初始化为“使用中”然后返回。
* 当对象不再被需要，它被设置回“不在使用中”。 
* 通过这种方式，可以轻易地创建和销毁对象而不必分配内存或其他资源。

### 优缺点

以空间换时间

### 与其他设计模式的关系

- 这看上去很像是**享元模式**。 两者都控制了一系列可重用的对象。不同在于“重用”的含义。 享元对象分享实例间*同时*拥有的相同部分。享元模式在不同上下文中使用相同对象避免了*重复*内存使用。

  对象池中的对象也被重用了，但是是在不同的时间点上被重用的。 “重用”在对象池中意味着对象在原先的对象用完*之后*分配内存。 对象池没有期待对象会在它的生命周期中分享什么。

- 将内存中同样类型的对象进行整合，能确保在遍历对象时CPU缓存总是满的。 **数据局部性模式**介绍了这一点。

## 空间分区

### 定义

将对象根据它们的位置存储在数据结构中，来高效地定位对象

### 场景

* 这是存储活跃的、移动的游戏对象的常用模式，也可用于静态美术和世界地理。 复杂的游戏中，不同的内容有不同的空间分区。

* 这个模式的基本要求是一系列有位置的对象，而你做了太多的通过位置寻找对象的查询，导致性能下降。

### 案例

### 实现方式

* 对于一系列**对象**，每个对象都有**空间上的位置**。 
* 将它们存储在根据位置组织对象的**空间数据结构**中，让你**有效查询在某处或者某处附近的对象**。 
* 当对象的位置改变时，**更新空间数据结构**，这样它可以继续找到对象。

### 优缺点

以空间换时间

### 与其他设计模式的关系

