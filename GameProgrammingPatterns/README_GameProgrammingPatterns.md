# Game Programming Patterns 游戏编程模式
Unity实现《游戏编程模式》

# 行为模式
- 

- 

## 类型对象

### 定义

创造一个类A来允许灵活地创造新“类型”，类A的每个实例都代表了不同的对象类型。

### 场景

- 你不知道你后面还需要什么类型。（举个例子，如果你的游戏需要支持资料包，而资料包有新的怪物品种呢？）
- 想不改变代码或者重新编译就能修改或添加新类型，即达到子类的名字、基本属性都是可以通过Json配置的目的

### 案例

[多类型的怪物](./Assets/BehavioralPatterns/TypeObject)

### 实现方式

* 定义**类型对象**类和**有类型的对象**类。

* 每个类型对象实例代表一种不同的逻辑类型。 

* 每种有类型的对象保存**对描述它类型的类型对象的引用**。

* 实例相关的数据被存储在有类型对象的实例中，被同种类分享的数据或者行为存储在类型对象中。 

* 引用同一类型对象的对象将会像同一类型一样运作。 

*这让我们在一组相同的对象间分享行为和数据，就像子类让我们做的那样，但没有固定的硬编码子类集合。*

### 优缺点

**优点**

* 可以快速、便捷的添加新的类型

**缺点**

* 更难为每种类型定义行为
* 需要手动追踪类型对象

### 与其他设计模式的关系

- 这个模式处理的高层问题是在多个对象间分享数据和行为。 另一个用另一种方式解决了相同问题的模式是**原型模式**。

- 类型对象是**享元模式**的近亲。 两者都让你在实例间**分享代码**。使用享元，意图是**节约内存**，而分享的数据也许不代表任何概念上对象的“类型”。 使用类型对象模式，焦点在组织性和灵活性。

- 这个模式和**状态模式**有很多相似之处。 两者都**委托对象的部分定义给另外一个对象**。 通过**类型对象**，我们通常委托了对象*是*什么：不变的数据概括描述对象。 通过**状态**，我们委托了对象*现在是什么*：暂时描述对象当前状态的数据。

  当我们讨论对象改变它的类型时，你可以认为类型对象起到了和状态相似的职责。

# 解耦模式
## 组件模式

### 定义

允许一个单一的实体跨越多个不同域而不会导致耦合。

### 场景

- 你有一个涉及多个域的类，但是你希望这些域保持相互解耦。
- 一个类越来越庞大，越来越难以开发。
- 你希望定义许多共享不同能力的对象，但采用继承的办法却无法令你精确地重用代码。

### 案例

[RPG游戏](./Assets/DecouplingPatterns/Component)

### 实现方式

* 单一实体跨越了多个领域。

* 为了保持领域之间相互分离，将每部分代码放入**各自的组件类**中。

* 实体被简化为*组件的容器*。

### 优缺点

**优点**

* 各个功能模块进行解耦

**缺点**

* 增加了组件之间的通信开销

### 与其他设计模式的关系

- 这种模式与GoF的策略模式类似。 两种模式都是将对象的行为取出，划入单独的重述对象。 与对象模式不同的是，分离的策略模式通常是无状态的——它封装了算法，而没有数据。 它定义了对象*如何*行动，但没有定义对象*是*什么。

  组件更加重要。它们经常保存了对象的状态，这有助于确定其真正的身份。 但是，这条界限很模糊。有一些组件也许根本没有任何状态。 在这种情况下，你可以在不同的容器对象中使用相同的组件*实例*。这样看来，它的行为确实更像一种策略。

## 事件队列

### 定义

事件队列在队列中按先入先出的顺序存储一系列通知或请求。 发送通知时，将请求放入队列并返回。 处理请求的系统之后稍晚从队列中获取请求并处理。 这解耦了发送者和接收者，既静态又及时。

### 场景

1. [通信](./Assets/DecouplingPatterns/EventQueue)

### 案例

[通信](./Assets/DecouplingPatterns/EventQueue)

### 实现方式

1. 制定消息类型，内容格式
2. 创建消息队列
3. 添加监听事件
4. 传递事件
5. 激活对应方法

### 优缺点

**优点**

* 解耦发送者和接收者

**缺点**

### 与其他设计模式的关系

- 我在之前提到了几次，很大程度上， 这个模式是广为人知的**观察者模式**的异步实现。

- 就像其他很多模式一样，事件队列有很多别名。 其中一个是“消息队列”。这通常指代一个更高层次的实现。 事件队列在应用*中*，消息队列通常在应用*间*交流。

  另一个术语是“发布/提交”，有时被缩写为“pubsub”。 就像“消息队列”一样，这通常指代更大的分布式系统，而不是现在关注的这个模式。

- 很像GoF的**状态模式**，需要一个输入流。如果想要**异步响应**，可以考虑用队列存储它们。

  当你有一对状态机相互发送消息时，每个状态机都有一个小小的未处理队列（被称为一个*信箱*）， 然后你需要重新发明[actor model](http://en.wikipedia.org/wiki/Actor_model)。

## 服务定位器

### 定义

提供服务的全局接入点，避免使用者和实现服务的具体类耦合。

### 场景

* 全局只有一个；建议和单例一样少用

### 案例

[全局声音管理](./Assets/DecouplingPatterns/ServiceLocator)

### 实现方式

* **服务** 类定义了一堆操作的抽象接口。

* 具体的**服务提供者**实现这个接口。 

* 分离的**服务定位器**提供了通过查询获取服务的方法，同时隐藏了服务提供者的具体细节和定位它的过程。

### 优缺点

**优点**

-  你可以保证一个类只有一个实例。
-  你获得了一个指向该实例的全局访问节点。
-  仅在首次请求对象时对其进行初始化。

**缺点**

-  违反了_单一职责原则_。 该模式同时解决了两个问题*(在一个方法中进行了创建类和提供类对象的操作)*。
-  单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。
-  该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。
-  客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用此模式。

### 与其他设计模式的关系

- **服务定位模式**在很多方面是**单例模式**的兄弟，在应用前值得看看哪个更适合你的需求。

# 优化模式
## 数据局部性

### 定义

合理组织数据，充分使用CPU的缓存来加速内存读取

### 场景

1. 性能问题确实由缓存不命中引起

### 案例

[更新大量相同组件](./Assets/OptimizationPatterns/DataLocality)

### 实现方式

* 现代的CPU有**缓存来加速内存读取**。

* 它可以**更快地读取最近访问过的内存的毗邻内存**。 

* 通过**提高内存局部性**来提高性能——保证数据**以处理顺序排列在连续内存上**。

### 优缺点

**优点**

1. 提高缓存利用率
2. 加快数据读写速度

**缺点**

* 系统更加复杂，更加缺乏灵活性

### 与其他设计模式的关系

- 这一模式几乎完全得益于同类对象的连续存储数组。 随着时间的推移，你也许需要向那个数组增加或删除对象。 **对象池模式**正是关于这一点。
- 这一章大部分围绕着**组件模式**。 这种模式的数据结构绝对是为缓存优化的最常见例子。事实上，使用组件模式让这种优化变得容易了。 由于实体是按“领域”（AI，物理，等等）更新的，将它们划出去变成组件，更容易将它们保存为对缓存友好的合适大小。但是这不意味你*只能*为组件使用这个模式！ 任何需要接触很多数据的关键代码，考虑数据局部性都是很重要的。

## 脏标识模式

### 定义

将工作延期至需要其结果时才去执行，避免不必要的工作

### 场景

- 原始数据的变化速度远高于导出数据的使用速度。 
- 增量更新十分困难。

### 案例

[渲染](./Assets/OptimizationPatterns/DirtyFlag)

### 实现方式

* 一组**原始数据**随着时间变化而改变。 
* 使用**代价昂贵的过程**推定一组**导出数据**。 
* 用一个**“脏”标识**追踪导出数据是否与原始数据保持一致。 
* 它在**原始数据改变时被设置。** 如果导出数据被请求时，该标识被设置了，那么**重新计算并清除标识** 否则的话，使用之前**缓存的导出数据**。

### 优缺点

**优点**

* 降低不必要的计算量

**缺点**

* 增加了系统复杂度

### 与其他设计模式的关系

独立的设计模式

## 对象池模式

### 定义

放弃单独地分配和释放对象，从固定的池中重用对象，以提高性能和内存使用率

### 场景

- 需要频繁创建和销毁对象。
- 对象大小相仿。
- 在堆上进行对象内存分配十分缓慢或者会导致内存碎片。
- 每个对象都封装了像数据库或者网络连接这样很昂贵又可以重用的资源。

### 案例

[对象池](./Assets/OptimizationPatterns/ObjectPool)

### 实现方式

* 定义一个**池**对象，其包含了一组**可重用对象**。
* 其中每个可重用对象都支持**查询“使用中”状态**，说明它是不是“正在使用”。
* 池被初始化时，它就创建了整个对象集合（通常使用一次连续的分配），然后初始化所有对象到“不在使用中”状态。
* 当你需要新对象，向池子要一个。 
* 它找到一个可用对象，初始化为“使用中”然后返回。
* 当对象不再被需要，它被设置回“不在使用中”。 
* 通过这种方式，可以轻易地创建和销毁对象而不必分配内存或其他资源。

### 优缺点

以空间换时间

### 与其他设计模式的关系

- 这看上去很像是**享元模式**。 两者都控制了一系列可重用的对象。不同在于“重用”的含义。 享元对象分享实例间*同时*拥有的相同部分。享元模式在不同上下文中使用相同对象避免了*重复*内存使用。

  对象池中的对象也被重用了，但是是在不同的时间点上被重用的。 “重用”在对象池中意味着对象在原先的对象用完*之后*分配内存。 对象池没有期待对象会在它的生命周期中分享什么。

- 将内存中同样类型的对象进行整合，能确保在遍历对象时CPU缓存总是满的。 **数据局部性模式**介绍了这一点。

## 空间分区

### 定义

将对象根据它们的位置存储在数据结构中，来高效地定位对象

### 场景

* 这是存储活跃的、移动的游戏对象的常用模式，也可用于静态美术和世界地理。 复杂的游戏中，不同的内容有不同的空间分区。

* 这个模式的基本要求是一系列有位置的对象，而你做了太多的通过位置寻找对象的查询，导致性能下降。

### 案例

### 实现方式

* 对于一系列**对象**，每个对象都有**空间上的位置**。 
* 将它们存储在根据位置组织对象的**空间数据结构**中，让你**有效查询在某处或者某处附近的对象**。 
* 当对象的位置改变时，**更新空间数据结构**，这样它可以继续找到对象。

### 优缺点

以空间换时间

### 与其他设计模式的关系

