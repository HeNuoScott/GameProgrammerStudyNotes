# Game Programming Patterns 游戏编程模式
Unity实现《游戏编程模式》

# 序列模式
## 双缓冲模式

### 定义

用序列的操作模拟瞬间或者同时发生的事情

### 场景

- 我们需要维护一些被增量修改的状态。
- 在修改到一半的时候，状态可能会被外部请求。
- 我们想要防止请求状态的外部代码知道内部的工作方式。
- 我们想要读取状态，而且不想等着修改完成。

### 案例

[图形系统](./Assets/SequencingPatterns/DoubleBuffer)

### 实现方式

定义*缓冲类*封装了**缓冲**：一段可改变的状态。 这个缓冲被增量地修改，但我们想要外部的代码将修改视为单一的原子操作。 为了实现这点，类保存了*两个*缓冲的实例：**下一缓冲**和**当前缓冲**。

当信息*从*缓冲区中读取，它总是读取*当前的*缓冲区。 当信息需要写*到*缓存，它总是在*下一*缓冲区上操作。 当改变完成后，一个**交换**操作会立刻将当前缓冲区和下一缓冲区交换， 这样新缓冲区就是公共可见的了。旧的缓冲区成为下一个重用的缓冲区。

### 优缺点

**优点**

* 双缓冲模式位于底层，它对代码库的其他部分影响较小

**缺点**

* 交换本身需要时间
* 保存两个缓冲区,增加了内存的使用

### 与其他设计模式的关系

独立的设计模式，需要它时自然会想起的模式

## 游戏循环

### 定义

在游玩中不断运行。 每一次循环，它无阻塞地处理玩家输入，更新游戏状态，渲染游戏。 它追踪时间的消耗并控制游戏的速度

### 场景

如果你使用游戏引擎，你不需要自己编写，但是它还在那里。

### 案例

[Unity内置游戏循环](./Assets/SequencingPatterns/GameLoop)

### 实现方式

[Unity内置游戏循环](./Assets/SequencingPatterns/GameLoop)

### 优缺点

- **使用平台的事件循环：**
  - *简单*。你不必担心编写和优化自己的游戏核心循环。
  - *平台友好。* 你不必明确地给平台一段时间让它处理它自己的事件，不必缓存事件，不必管理任何平台输入模型和你的不匹配之处。
  - *你失去了对时间的控制。* 平台会在它方便时调用代码。 如果这不如你想要的那样平滑或者频繁，太糟了。 更糟的是，大多数应用的事件循环并未为游戏设计，通常*是*又慢又卡顿。
- **使用游戏引擎的循环：**
  - *不必自己编写。* 编写游戏循环非常需要技巧。 由于是每帧都要执行的核心代码，小小的漏洞或者性能问题就对游戏有巨大的影响。 稳固的游戏循环是使用现有引擎的原因之一。
  - *不必自己编写。* 当然，硬币的另一面是，如果引擎无法满足你*真正的*需求，你也没法获得控制权。
- **自己写：**
  - *完全的控制。* 你可以做任何想做的事情。你可以为游戏的需求订制开发。
  - *你需要与平台交互。* 应用框架和操作系统通常需要时间片去处理自己的事件和其他工作。 如果你拥有应用的核心循环，平台就没有这些时间片了。 你得显式定期检查，保证框架没有挂起或者混乱。

### 与其他设计模式的关系

独立的设计模式，需要它时自然会想起的模式

## 更新方法

### 定义

通过每次处理一帧的行为模拟一系列独立对象；

### 场景

- 你的游戏有很多对象或系统需要同时运行。
- 每个对象的行为都与其他的大部分独立。
- 对象需要跟着时间进行模拟。

### 案例

[对象的更新行为](./Assets/SequencingPatterns/UpdateMethod)

### 实现方式

* **游戏世界**管理**对象集合**。 

* 每个对象实现一个**更新方法**模拟对象在**一帧**内的行为。

* 每一帧，游戏循环更新集合中的每一个对象。

### 优缺点

**优点**

* 对象行为独立于游戏世界

**缺点**

* 增加系统复杂度

### 与其他设计模式的关系

- 这个模式，以及**游戏循环**模式和**组件模式**，是构建游戏引擎核心的三位一体。
- 当你关注在每帧中更新实体或组件的缓存性能时，**数据局部性模式**可以让它跑到更快。
- [Unity](http://unity3d.com/)框架在多个类中使用了这个模式，包括 [`MonoBehaviour`](http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.Update.html)。

# 行为模式
## 字节码

### 定义

将行为编码为虚拟机器上的指令，赋予其数据的灵活性

### 场景

* 应当用在你有许多行为需要定义，例如：一系列的法术技能

### 案例

[法术技能](./Assets/BehavioralPatterns/Bytecode)

### 实现方式

* **指令集** 定义了可执行的底层操作。

* 一系列的指令被编码为**字节序列**。 

* **虚拟机** 使用 **中间值栈** 依次执行这些指令。

* 通过组合指令，可以定义复杂的高层行为。

### 优缺点

**优点**

* 可扩展性比较好，灵活。
* 增加了新的解释表达式的方式。
* 易于实现简单文法。

**缺点**

- 过于底层，繁琐易错。
- 编译慢或者其他工具因素导致迭代缓慢。
- 安全性依赖编程者。如果想保证行为不会破坏游戏，你需要将其与代码的其他部分隔开。

### 与其他设计模式的关系

- 这一章节的近亲是GoF的[解释器模式](http://en.wikipedia.org/wiki/Interpreter_pattern)。两种方式都能让你用**数据组合行为**。

  事实上，最终你两种模式*都*会使用。你用来构造字节码的工具会有内部的对象树。这也是**解释器模式**所能做的。

  为了编译到字节码，你需要递归回溯整棵树，就像用**解释器模式**去解释它一样。 *唯一的* 不同在于，**不是立即执行一段行为**，而是生成整个字节码再执行。

## 子类沙箱

### 定义

用一系列由基类提供的操作定义子类中的行为。

### 场景

- 你有一个能推导很多子类的基类。
- 基类可以提供子类需要的所有操作。
- 在子类中有行为重复，你想要更容易地在它们间分享代码。
- 你想要最小化子类和程序的其他部分的耦合。

### 案例

[超级英雄](./Assets/BehavioralPatterns/SubclassSandbox)

### 实现方式

* **基类**定义抽象的**沙箱方法**和几个**提供的操作**。

* 将操作标为protected，表明它们只为子类所使用。

* 每个推导出的**沙箱子类**用提供的操作实现了沙箱函数。

### 优缺点

**优点**

* 通过超级父类可以快速构建只有部分功能的子类

**缺点**

* 会有很多冗余代码。
* 游戏引擎中的每一部分都会与这些类耦合。
* 当外部代码需要改变时，一些随机超能力代码有很大几率会损坏。

### 与其他设计模式的关系

- 当你使用**更新模式**时，你的更新函数通常也是沙箱方法。
- 这个模式与**模板方法** *(GOF)*正相反。 两种模式中，都使用一系列受限操作实现方法。 使用子类沙箱时，方法在推导类中，受限操作在基类中。 使用模板方法时，*基类* 有方法，而受限操作在*推导*类中。
- 你也可以认为这个模式是**外观模式**  *(GOF)*的变形。 外观模式将一系列不同系统藏在简化的API后。使用子类沙箱，基类起到了在子类前隐藏整个游戏引擎的作用。

## 类型对象

### 定义

创造一个类A来允许灵活地创造新“类型”，类A的每个实例都代表了不同的对象类型。

### 场景

- 你不知道你后面还需要什么类型。（举个例子，如果你的游戏需要支持资料包，而资料包有新的怪物品种呢？）
- 想不改变代码或者重新编译就能修改或添加新类型，即达到子类的名字、基本属性都是可以通过Json配置的目的

### 案例

[多类型的怪物](./Assets/BehavioralPatterns/TypeObject)

### 实现方式

* 定义**类型对象**类和**有类型的对象**类。

* 每个类型对象实例代表一种不同的逻辑类型。 

* 每种有类型的对象保存**对描述它类型的类型对象的引用**。

* 实例相关的数据被存储在有类型对象的实例中，被同种类分享的数据或者行为存储在类型对象中。 

* 引用同一类型对象的对象将会像同一类型一样运作。 

*这让我们在一组相同的对象间分享行为和数据，就像子类让我们做的那样，但没有固定的硬编码子类集合。*

### 优缺点

**优点**

* 可以快速、便捷的添加新的类型

**缺点**

* 更难为每种类型定义行为
* 需要手动追踪类型对象

### 与其他设计模式的关系

- 这个模式处理的高层问题是在多个对象间分享数据和行为。 另一个用另一种方式解决了相同问题的模式是**原型模式**。

- 类型对象是**享元模式**的近亲。 两者都让你在实例间**分享代码**。使用享元，意图是**节约内存**，而分享的数据也许不代表任何概念上对象的“类型”。 使用类型对象模式，焦点在组织性和灵活性。

- 这个模式和**状态模式**有很多相似之处。 两者都**委托对象的部分定义给另外一个对象**。 通过**类型对象**，我们通常委托了对象*是*什么：不变的数据概括描述对象。 通过**状态**，我们委托了对象*现在是什么*：暂时描述对象当前状态的数据。

  当我们讨论对象改变它的类型时，你可以认为类型对象起到了和状态相似的职责。

# 解耦模式
## 组件模式

### 定义

允许一个单一的实体跨越多个不同域而不会导致耦合。

### 场景

- 你有一个涉及多个域的类，但是你希望这些域保持相互解耦。
- 一个类越来越庞大，越来越难以开发。
- 你希望定义许多共享不同能力的对象，但采用继承的办法却无法令你精确地重用代码。

### 案例

[RPG游戏](./Assets/DecouplingPatterns/Component)

### 实现方式

* 单一实体跨越了多个领域。

* 为了保持领域之间相互分离，将每部分代码放入**各自的组件类**中。

* 实体被简化为*组件的容器*。

### 优缺点

**优点**

* 各个功能模块进行解耦

**缺点**

* 增加了组件之间的通信开销

### 与其他设计模式的关系

- 这种模式与GoF的策略模式类似。 两种模式都是将对象的行为取出，划入单独的重述对象。 与对象模式不同的是，分离的策略模式通常是无状态的——它封装了算法，而没有数据。 它定义了对象*如何*行动，但没有定义对象*是*什么。

  组件更加重要。它们经常保存了对象的状态，这有助于确定其真正的身份。 但是，这条界限很模糊。有一些组件也许根本没有任何状态。 在这种情况下，你可以在不同的容器对象中使用相同的组件*实例*。这样看来，它的行为确实更像一种策略。

## 事件队列

### 定义

事件队列在队列中按先入先出的顺序存储一系列通知或请求。 发送通知时，将请求放入队列并返回。 处理请求的系统之后稍晚从队列中获取请求并处理。 这解耦了发送者和接收者，既静态又及时。

### 场景

1. [通信](./Assets/DecouplingPatterns/EventQueue)

### 案例

[通信](./Assets/DecouplingPatterns/EventQueue)

### 实现方式

1. 制定消息类型，内容格式
2. 创建消息队列
3. 添加监听事件
4. 传递事件
5. 激活对应方法

### 优缺点

**优点**

* 解耦发送者和接收者

**缺点**

### 与其他设计模式的关系

- 我在之前提到了几次，很大程度上， 这个模式是广为人知的**观察者模式**的异步实现。

- 就像其他很多模式一样，事件队列有很多别名。 其中一个是“消息队列”。这通常指代一个更高层次的实现。 事件队列在应用*中*，消息队列通常在应用*间*交流。

  另一个术语是“发布/提交”，有时被缩写为“pubsub”。 就像“消息队列”一样，这通常指代更大的分布式系统，而不是现在关注的这个模式。

- 很像GoF的**状态模式**，需要一个输入流。如果想要**异步响应**，可以考虑用队列存储它们。

  当你有一对状态机相互发送消息时，每个状态机都有一个小小的未处理队列（被称为一个*信箱*）， 然后你需要重新发明[actor model](http://en.wikipedia.org/wiki/Actor_model)。

## 服务定位器

### 定义

提供服务的全局接入点，避免使用者和实现服务的具体类耦合。

### 场景

* 全局只有一个；建议和单例一样少用

### 案例

[全局声音管理](./Assets/DecouplingPatterns/ServiceLocator)

### 实现方式

* **服务** 类定义了一堆操作的抽象接口。

* 具体的**服务提供者**实现这个接口。 

* 分离的**服务定位器**提供了通过查询获取服务的方法，同时隐藏了服务提供者的具体细节和定位它的过程。

### 优缺点

**优点**

-  你可以保证一个类只有一个实例。
-  你获得了一个指向该实例的全局访问节点。
-  仅在首次请求对象时对其进行初始化。

**缺点**

-  违反了_单一职责原则_。 该模式同时解决了两个问题*(在一个方法中进行了创建类和提供类对象的操作)*。
-  单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。
-  该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。
-  客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用此模式。

### 与其他设计模式的关系

- **服务定位模式**在很多方面是**单例模式**的兄弟，在应用前值得看看哪个更适合你的需求。

# 优化模式
## 数据局部性

### 定义

合理组织数据，充分使用CPU的缓存来加速内存读取

### 场景

1. 性能问题确实由缓存不命中引起

### 案例

[更新大量相同组件](./Assets/OptimizationPatterns/DataLocality)

### 实现方式

* 现代的CPU有**缓存来加速内存读取**。

* 它可以**更快地读取最近访问过的内存的毗邻内存**。 

* 通过**提高内存局部性**来提高性能——保证数据**以处理顺序排列在连续内存上**。

### 优缺点

**优点**

1. 提高缓存利用率
2. 加快数据读写速度

**缺点**

* 系统更加复杂，更加缺乏灵活性

### 与其他设计模式的关系

- 这一模式几乎完全得益于同类对象的连续存储数组。 随着时间的推移，你也许需要向那个数组增加或删除对象。 **对象池模式**正是关于这一点。
- 这一章大部分围绕着**组件模式**。 这种模式的数据结构绝对是为缓存优化的最常见例子。事实上，使用组件模式让这种优化变得容易了。 由于实体是按“领域”（AI，物理，等等）更新的，将它们划出去变成组件，更容易将它们保存为对缓存友好的合适大小。但是这不意味你*只能*为组件使用这个模式！ 任何需要接触很多数据的关键代码，考虑数据局部性都是很重要的。

## 脏标识模式

### 定义

将工作延期至需要其结果时才去执行，避免不必要的工作

### 场景

- 原始数据的变化速度远高于导出数据的使用速度。 
- 增量更新十分困难。

### 案例

[渲染](./Assets/OptimizationPatterns/DirtyFlag)

### 实现方式

* 一组**原始数据**随着时间变化而改变。 
* 使用**代价昂贵的过程**推定一组**导出数据**。 
* 用一个**“脏”标识**追踪导出数据是否与原始数据保持一致。 
* 它在**原始数据改变时被设置。** 如果导出数据被请求时，该标识被设置了，那么**重新计算并清除标识** 否则的话，使用之前**缓存的导出数据**。

### 优缺点

**优点**

* 降低不必要的计算量

**缺点**

* 增加了系统复杂度

### 与其他设计模式的关系

独立的设计模式

## 对象池模式

### 定义

放弃单独地分配和释放对象，从固定的池中重用对象，以提高性能和内存使用率

### 场景

- 需要频繁创建和销毁对象。
- 对象大小相仿。
- 在堆上进行对象内存分配十分缓慢或者会导致内存碎片。
- 每个对象都封装了像数据库或者网络连接这样很昂贵又可以重用的资源。

### 案例

[对象池](./Assets/OptimizationPatterns/ObjectPool)

### 实现方式

* 定义一个**池**对象，其包含了一组**可重用对象**。
* 其中每个可重用对象都支持**查询“使用中”状态**，说明它是不是“正在使用”。
* 池被初始化时，它就创建了整个对象集合（通常使用一次连续的分配），然后初始化所有对象到“不在使用中”状态。
* 当你需要新对象，向池子要一个。 
* 它找到一个可用对象，初始化为“使用中”然后返回。
* 当对象不再被需要，它被设置回“不在使用中”。 
* 通过这种方式，可以轻易地创建和销毁对象而不必分配内存或其他资源。

### 优缺点

以空间换时间

### 与其他设计模式的关系

- 这看上去很像是**享元模式**。 两者都控制了一系列可重用的对象。不同在于“重用”的含义。 享元对象分享实例间*同时*拥有的相同部分。享元模式在不同上下文中使用相同对象避免了*重复*内存使用。

  对象池中的对象也被重用了，但是是在不同的时间点上被重用的。 “重用”在对象池中意味着对象在原先的对象用完*之后*分配内存。 对象池没有期待对象会在它的生命周期中分享什么。

- 将内存中同样类型的对象进行整合，能确保在遍历对象时CPU缓存总是满的。 **数据局部性模式**介绍了这一点。

## 空间分区

### 定义

将对象根据它们的位置存储在数据结构中，来高效地定位对象

### 场景

* 这是存储活跃的、移动的游戏对象的常用模式，也可用于静态美术和世界地理。 复杂的游戏中，不同的内容有不同的空间分区。

* 这个模式的基本要求是一系列有位置的对象，而你做了太多的通过位置寻找对象的查询，导致性能下降。

### 案例

### 实现方式

* 对于一系列**对象**，每个对象都有**空间上的位置**。 
* 将它们存储在根据位置组织对象的**空间数据结构**中，让你**有效查询在某处或者某处附近的对象**。 
* 当对象的位置改变时，**更新空间数据结构**，这样它可以继续找到对象。

### 优缺点

以空间换时间

### 与其他设计模式的关系

