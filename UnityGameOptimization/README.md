# 第1章 检测性能问题 

1. 性能分析的最佳方法
   * 验证场景中是否存在目标脚本

   * 验证脚本在场景中出现的次数
   * 尽量减少对正在进行的代码的更改
   * 最小化内部干扰
   * 最小化外部干扰

# 第2章 脚本编写策略

1. 缓存组件引用

   在Awake、Start等初始化期间缓存组件，不要每次用每次GetComponent

2. 使用最快的方法获取组

   根据测试GetComponent<T>，在所有GetComponent最快

3. 删除空的回调声明

   空的Start、Update方法也是会调用的

4. 在运行时避免使用Find()和SendMessage()方法

   * 静态类

   * 单例组件

   * 分配对现有对象的引用 

   * 全局消息系统 

     像[TinyMessenger](https://github.com/grumpydev/TinyMessenger)等，且Unity的相关的框架基本都有自己的消息系统

5. 禁用未使用的脚本和对象 

   * 按可见性禁用对象 

     视锥体剔除回调方法：OnBecameVisible 和 OnBecameInvisible

   * 按距离禁用对象 

6. 考虑使用距离平方值 

   CPU 比较擅长计算浮点数的乘法，但是要计算平方根却相对比较困难。每次我们要求 Vector3 使用magnitude 属性或 Distance方法计算距离时，都会要求它执行乎方根计算（根据毕达哥拉斯定理）。但是，Vector3 类还提供了一个 sarMagnitude 属性，该属性与 distance相同，不同之处在于它计算的是平方值。这使我们能够进行基本相同的比较检查，而无须包含昂贵的平方根计算，只要我们对要进行比较的值进行平方即可。如果A的magnitude 小于 B的magnitude，则A将小于B。

7. 避免从GameObject中检索字符串属性

   GameObject.tag或者name属性都会引起字符串的复制，从而引起堆内存的分配，但是CompareTag方法不会。

8. 更新和协程选择和优化

9. 考虑缓存Transform值的更改 

   * 变换组件 （Transform Component）仅存储相对于其自身父级的数据。这意味着访问和修改变换组件的 position（位置）、rotation（旋转）和 scale(缩放）属性可能会导致很多意外的矩阵乘法计算，从而通过其父对象的变换为对象生成正确的变换表示形式，所以推荐使用localPosition、localRotation、localScale
   * 设置脏标示，只有需要修改时才修改Transform属性

10. 更快的GameObject空引用检查 

    gameObject == null会调用原生托管桥另一端的方法，推荐使用System.Object. ReferenceEquals (gameObject, null)，当然这个方法产生较好的收益的前提是需要大量的执行gameObject == null此判断。

# 第3章 批处理的好处 

1. 绘制调用 Draw Call

   绘制调用就是从 CPU 发送到GPU 的请求，要求它绘制对象。但是，在可以请求绘制调用之前，需要满足几个重要条件。首先，必须将网格和纹理数据从CPU 内存（RAM推送到GPU 显存 (VRAM)，这通常是在场景初始化期问发生的。接下来，CPU 必须通过配置选项和渲染功能来准备 GPU，这些都是处理作为绘制调用目标的对象所需的。CPU 和GPU 之间的这些通信任务可以通过基本的图形 API 进行，根据我们所针对的平台和某些图形设置，这些图形 API可以是DirectX 或 OpenGL。这些 API 具有许多可以配置的复杂且相互关联的设置、状态量和数据集，并且可用功能会根据我们所操作的硬件设备而发生巨大变化。在渲染单个对象之前，可以配置的大量设置通常会被浓缩为一个称为渲染状态(Render State）的术语。在更改这些渲染状态选项之前，GPU 将为所
   有传入的对象保持相同的渲染状态，并以类似的方式渲染它们。

   **更改谊染状态可能是一个耗时的过程**

2. 动态批处理条件
   * 所有网格实例必须使用相同的材质引用。
   * 仅动态批处理粒子系统和网格渲染器。蒙皮的网格渲染器（用于动画角色）和所有其他可渲染组件类型无法批处理。
   * 着色器使用的顶点属性总数必须不超过 900。
   * 所有网格实例都应使用均匀的缩放比例，或者所有网格都应使用不均匀的缩放比例，但不能两者兼有。
   * 材质的着色器不应取决于多通道。
   * 网格实例不得接收实时阴影。
   * 在一些联合小组会议上还揭示了若干不成文的要求：
     * 每个批处理限制为 300个网格。
     * 整个批处理中的索引不得超过 32000个网格。

3. 动态批处理应用场景
   * 一片大森林，到处都是岩石、树木和灌木丛。
   * 建筑物、工厂或宇宙空间站，场景中有许多常见元素 （如计算机、管道等）。
   * 游戏中包含许多具有简单几何形状的动态非动画对象和粒子效果（想象一下《几何大战》这样的游戏）。

4. 静态批处理条件
   * 网格必须标记为 Static(静态）
   * 必须为静态批处理的每个网格留出额外的内存，即两倍内存换渲染时间。
   * 网格实例可以来自任何源网格，但是它们必须共享相同的材质。

5. 静态批处理注意事项 
   * 节省的绘制调用数无法立即从 Stats（统计）窗口中看到，必须等到运行时。
   * 静态对象不应在运行时引入场景。
   * 静态批处理的网格无法从其原始变换移动。
   * 如果有任何一个静态批处理的网格是可见的，则整个组都将被渲染。

第4章 快速启动艺术资产 

4.1 音频 

4.1.1 加载音频文件 

4.1.2 编码格式和质量等级 

4.1.3 音频性能增强 

4.2 纹理文件 

4.2.1 压缩格式 

4.2.2 纹理性能增强 

4.3 网格和动画文件 

4.3.1 减少多边形数量 

4.3.2 仅导入/计算所需内容 

4.3.3 考虑烘焙动画 

4.3.4 让Unity优化网格 

4.3.5 合并网格 

4.4 小结 

第5章 更快的物理引擎 

5.1 物理引擎内部 

5.1.1 物理与时间 

5.1.2 静态和动态碰撞器 

5.1.3 碰撞检测 

5.1.4 碰撞类型 

5.1.5 碰撞矩阵 

5.1.6 刚体活动和睡眠状态 

5.1.7 光线和对象投射 

5.2 物理性能优化 

5.2.1 场景设置 

5.2.2 正确使用静态碰撞器 

5.2.3 优化碰撞矩阵 

5.2.4 首选离散碰撞检测 

5.2.5 修改固定更新频率 

5.2.6 调整最大允许时间步长 

5.2.7 最小化投射和包围体检查 

5.2.8 避免使用复杂的网格碰撞器 

5.2.9 避免复杂的物理组件 

5.2.10 让物理对象睡眠 

5.2.11 修改求解器迭代计数 

5.2.12 优化布娃娃 

5.2.13 掌握使用物理引擎的时机 

5.2.14 考虑升级到Unity 5 

5.3 小结 

第6章 动态图形 

6.1 分析渲染问题 

6.1.1 对GPU进行性能分析 

6.1.2 帧调试器 

6.1.3 强力测试 

6.1.4 受CPU限制 

6.2 前端瓶颈 

6.2.1 细节级别 

6.2.2 禁用GPU蒙皮 

6.2.3 减少曲面细分 

6.3 后端瓶颈 

6.3.1 填充速率 

6.3.2 内存带宽 

6.3.3 关于VRAM限制 

6.4 照明和阴影 

6.4.1 正向渲染 

6.4.2 延迟着色 

6.4.3 顶点照明着色 

6.4.4 实时阴影 

6.4.5 照明优化 

6.5 为移动设备优化图形 

6.5.1 尽量减少绘制调用 

6.5.2 尽量减少材质数量 

6.5.3 最小化纹理大小和材质数量 

6.5.4 使用正方形和2的幂纹理 

6.5.5 在着色器中使用最低精确度格式 

6.5.6 避免进行Alpha测试 

6.6 小结 

第7章 精通内存管理 

7.1 关于Mono平台 

7.1.1 编译过程 

7.1.2 手动JIT编译 

7.2 内存使用优化 

7.2.1 关于Unity内存域 

7.2.2 值类型和引用类型 

7.2.3 数据布局的重要性 

7.2.4 关于Unity API 

7.2.5 关于foreach循环 

7.2.6 协程 

7.2.7 闭包 

7.2.8 关于.NET库函数 

7.2.9 临时工作缓冲区 

7.2.10 对象池 

7.3 预制件池 

7.3.1 可池化的组件 

7.3.2 预制件池系统

7.3.3 预制件池 

7.3.4 对象生成 

7.3.5 预生成实例

7.3.6 对象取消生成 

7.3.7 预制件池测试 

7.3.8 预制件池和场景加载 

7.3.9 预制件池小结 

7.4 关于Mono和Unity的未来 

7.5 小结 

第8章 提示和技巧 

8.1 编辑器热键提示 

8.1.1 和GameObject有关的热键 

8.1.2 场景视图 

8.1.3 数组 

8.1.4 接口 

8.1.5 其他 

8.2 编辑器界面提示 

8.2.1 常规提示 

8.2.2 检查器视图 

8.2.3 项目视图 

8.2.4 分层结构视图 

8.2.5 场景和游戏视图

8.2.6 播放模式 

8.3 脚本编写技巧 

8.3.1 常规技巧 

8.3.2 属性 

8.3.3 记录日志 

8.3.4 有用的链接 

8.4 自定义编辑器/菜单提示 

8.5 外部提示 

8.6 小结 