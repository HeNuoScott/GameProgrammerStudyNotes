# 第1章 检测性能问题 

1. 性能分析的最佳方法
   * 验证场景中是否存在目标脚本

   * 验证脚本在场景中出现的次数
   * 尽量减少对正在进行的代码的更改
   * 最小化内部干扰
   * 最小化外部干扰

# 第2章 脚本编写策略

1. 缓存组件引用

   在Awake、Start等初始化期间缓存组件，不要每次用每次GetComponent

2. 使用最快的方法获取组

   根据测试GetComponent<T>，在所有GetComponent最快

3. 删除空的回调声明

   空的Start、Update方法也是会调用的

4. 在运行时避免使用Find()和SendMessage()方法

   * 静态类

   * 单例组件

   * 分配对现有对象的引用 

   * 全局消息系统 

     像[TinyMessenger](https://github.com/grumpydev/TinyMessenger)等，且Unity的相关的框架基本都有自己的消息系统

5. 禁用未使用的脚本和对象 

   * 按可见性禁用对象 

     视锥体剔除回调方法：OnBecameVisible 和 OnBecameInvisible

   * 按距离禁用对象 

6. 考虑使用距离平方值 

   CPU 比较擅长计算浮点数的乘法，但是要计算平方根却相对比较困难。每次我们要求 Vector3 使用magnitude 属性或 Distance方法计算距离时，都会要求它执行乎方根计算（根据毕达哥拉斯定理）。但是，Vector3 类还提供了一个 sarMagnitude 属性，该属性与 distance相同，不同之处在于它计算的是平方值。这使我们能够进行基本相同的比较检查，而无须包含昂贵的平方根计算，只要我们对要进行比较的值进行平方即可。如果A的magnitude 小于 B的magnitude，则A将小于B。

7. 避免从GameObject中检索字符串属性

   GameObject.tag或者name属性都会引起字符串的复制，从而引起堆内存的分配，但是CompareTag方法不会。

8. 更新和协程选择和优化

9. 考虑缓存Transform值的更改 

   * 变换组件 （Transform Component）仅存储相对于其自身父级的数据。这意味着访问和修改变换组件的 position（位置）、rotation（旋转）和 scale(缩放）属性可能会导致很多意外的矩阵乘法计算，从而通过其父对象的变换为对象生成正确的变换表示形式，所以推荐使用localPosition、localRotation、localScale
   * 设置脏标示，只有需要修改时才修改Transform属性

10. 更快的GameObject空引用检查 

    gameObject == null会调用原生托管桥另一端的方法，推荐使用System.Object. ReferenceEquals (gameObject, null)，当然这个方法产生较好的收益的前提是需要大量的执行gameObject == null此判断。

# 第3章 批处理的好处 

1. 绘制调用 Draw Call

   绘制调用就是从 CPU 发送到GPU 的请求，要求它绘制对象。但是，在可以请求绘制调用之前，需要满足几个重要条件。首先，必须将网格和纹理数据从CPU 内存（RAM推送到GPU 显存 (VRAM)，这通常是在场景初始化期问发生的。接下来，CPU 必须通过配置选项和渲染功能来准备 GPU，这些都是处理作为绘制调用目标的对象所需的。CPU 和GPU 之间的这些通信任务可以通过基本的图形 API 进行，根据我们所针对的平台和某些图形设置，这些图形 API可以是DirectX 或 OpenGL。这些 API 具有许多可以配置的复杂且相互关联的设置、状态量和数据集，并且可用功能会根据我们所操作的硬件设备而发生巨大变化。在渲染单个对象之前，可以配置的大量设置通常会被浓缩为一个称为渲染状态(Render State）的术语。在更改这些渲染状态选项之前，GPU 将为所
   有传入的对象保持相同的渲染状态，并以类似的方式渲染它们。

   **更改谊染状态可能是一个耗时的过程**

2. 动态批处理条件
   * 所有网格实例必须使用相同的材质引用。
   * 仅动态批处理粒子系统和网格渲染器。蒙皮的网格渲染器（用于动画角色）和所有其他可渲染组件类型无法批处理。
   * 着色器使用的顶点属性总数必须不超过 900。
   * 所有网格实例都应使用均匀的缩放比例，或者所有网格都应使用不均匀的缩放比例，但不能两者兼有。
   * 材质的着色器不应取决于多通道。
   * 网格实例不得接收实时阴影。
   * 在一些联合小组会议上还揭示了若干不成文的要求：
     * 每个批处理限制为 300个网格。
     * 整个批处理中的索引不得超过 32000个网格。

3. 动态批处理应用场景
   * 一片大森林，到处都是岩石、树木和灌木丛。
   * 建筑物、工厂或宇宙空间站，场景中有许多常见元素 （如计算机、管道等）。
   * 游戏中包含许多具有简单几何形状的动态非动画对象和粒子效果（想象一下《几何大战》这样的游戏）。

4. 静态批处理条件
   * 网格必须标记为 Static(静态）
   * 必须为静态批处理的每个网格留出额外的内存，即两倍内存换渲染时间。
   * 网格实例可以来自任何源网格，但是它们必须共享相同的材质。

5. 静态批处理注意事项 
   * 节省的绘制调用数无法立即从 Stats（统计）窗口中看到，必须等到运行时。
   * 静态对象不应在运行时引入场景。
   * 静态批处理的网格无法从其原始变换移动。
   * 如果有任何一个静态批处理的网格是可见的，则整个组都将被渲染。

# 第4章 快速启动艺术资产 

一、音频 

**Load Type（加载类型）：**

* Decompress On Load（载入时解压缩）

  可压缩磁盘上的文件以节省空间，并在首次加载时将其解压缩到内存中，这是加载音频文件的标准方法，应在大多数情况下使用。

* Compressed In Memory（压缩在内存中）

  在加载时将压缩文件直按加载到内存中，在运行时期间，当需要播放时才对其进行解压缩。播放剪辑时，这将牺牲运行时 CPU,但会提高加载速度并减少运行时的内存消耗。因此，此选项最适合用于经常使用的非常大的音频文件，或者如果程序的内存消耗成为瓶颈，而我们愿意牺牲一些 CPU 周期来播放音频剪辑，则也可以选择此选项。

* Streaming(流媒体）。


  它可以通过逐步将文件推入一个小缓冲区，在运行时即时加载、解码和搔放文件。此方法对于特定的音频剪辑将使用最少的内存，并使用最大的运行时 CPU。这带来计后果此使用将导致大量的内存和运行时 CPU 开销。因此，此选项最适合定期播放目秀然气其他实例重種的单实例音场剪辑。也就是说，该设置最活谷在场系的整个生命周開中都需要播放的背景音乐和环境声音效果中使用。

**编码格式和质量等级** 

* Compressed(压缩格式)

  与Compressed格式一起使用的压缩算法将取决于它所针对的平台。例如，独立应用程序、WebGL 和其他非移动平台将使用 Ogg-Vorbis 进行压缩，而移动平合则多使用MPEG-3 (MP3）格式。

* PCM.

  PCM格式是无损且未压縮的音场格式，提供了与橫拟音频的近似。它以较大的文件量换取更高的音频质量，并且最适合用于非常短的声音效果，这些效果要求非常清晰，否则任何压缩都会使体验失真。

* ADPCM.

  ADPCM 格式在大小和 CPU 消耗方面都比 PCM 高效得多，但是压缩会产生大量噪声。如果我们的音效是短暂而混乱的，例如爆炸、碰撞和撞击声，那么在其中夹杂这样的噪声显然没有任何问题，听众将完全感受不到。

*最后，Compressed 格式产生的文件要比 PCM 格式小，而声音质量也更低（但是它的质量比 ADPCM 要好得多），但会占用额外的运行时 CPU 使用率。在大多数情况下应使用此格式。此选项使我们可以自定义压缩算法的最终质量级别，以根据需要的文件大小调整质量。使用 Quality（质量）滑块的最佳做法是找到尽可能小的声音质量级别（但不应该让用户注意到质量太差）。要找到每个文件的 “最佳质量级别”，可能需要由用户进行一些实际的测试体验*

**音频性能增强** 

1. 尽量减少活动音频源数量
2. 尽量减少音频剪辑引用
   解决方案是利用 Resourees L.oad0和 ResOurces. UnloadAsset0将音频数据仅在播放时粮道在內存中，然后在不再需要用立即释放它。
3. 为30声音启用强制单声道选项
4. 重新采样以降低频率
5. 考虑所有编码格式
   如果应用程序没有内存和硬盘消耗方面的负担，则 WAV 格式可用于减少运行时的CPU 成本。因为在每次播放期间，该格式解码数据所需的开销较小。同时，如果有空府的CPU 周期，厕可以通过床缩编码格式节省空间。
6. 谨慎使用流媒体
   从磁盘流式传输文件应仅限于大型单实例文件，因为它需要运行时磁盘访问权限，这是我们可以使用的最慢的数据访问形式之一。使用此方法的，分层或过渡的音乐剪辑可能合出现重大问题，此时考虑使用 Resources Loado方法才是明智的。
7. 通过混合器组应用滤镜效果以减少重复
8. 负责任地使用 wwW.audioClip
   Unity 的 www 类可用于通过网络流式传输游戏内容。但是，访问 www 对象的audioClip 属性将在每次调用它时分配一个全新的 Audio Clip 资源，并且它获取资源的方法与其他 www 资源获取方法类似。一且不再需要此资源，则必须使用 Resources.UnloadAsset方法将其释放。丢弃可用(将其设置为 null)不会自动释放资源，因此它将继续消耗内存。有鉴于此，我们应该只通过一次audioClip 属性获得音频剪辑，以获取资源引用，从此以后仅使用该引用，并在不再需要时释放它。
9. 考虑将音频模块文件用作背景音乐
   音频模块（Audio Module）文件也称为音轨模块（Tracker Module），是一种节省大量空间而又不会引起明显质量损失的极好方法。Unity 中支持的文件扩展名是.it、.s3m、.xm和.mod。与常见的 PCM 音频格式不同，后者是作为数据的位流读取的，必须在运行时对其进行解码才能生成特定的声音，而音轨模块则包含许多小的高质量 PCM 采样，并像乐谱一样组织整个音轨，定义播放每个样本的时问、位置、音量、音调以及特殊效果。这可以节省很多的文件量，同时又保持高质量的采样。

4.2 纹理文件 

4.2.1 压缩格式 

4.2.2 纹理性能增强 

4.3 网格和动画文件 

4.3.1 减少多边形数量 

4.3.2 仅导入/计算所需内容 

4.3.3 考虑烘焙动画 

4.3.4 让Unity优化网格 

4.3.5 合并网格 

4.4 小结 

# 第5章 更快的物理引擎 

5.1 物理引擎内部 

5.1.1 物理与时间 

5.1.2 静态和动态碰撞器 

5.1.3 碰撞检测 

5.1.4 碰撞类型 

5.1.5 碰撞矩阵 

5.1.6 刚体活动和睡眠状态 

5.1.7 光线和对象投射 

5.2 物理性能优化 

5.2.1 场景设置 

5.2.2 正确使用静态碰撞器 

5.2.3 优化碰撞矩阵 

5.2.4 首选离散碰撞检测 

5.2.5 修改固定更新频率 

5.2.6 调整最大允许时间步长 

5.2.7 最小化投射和包围体检查 

5.2.8 避免使用复杂的网格碰撞器 

5.2.9 避免复杂的物理组件 

5.2.10 让物理对象睡眠 

5.2.11 修改求解器迭代计数 

5.2.12 优化布娃娃 

5.2.13 掌握使用物理引擎的时机 

5.2.14 考虑升级到Unity 5 

5.3 小结 

# 第6章 动态图形 

6.1 分析渲染问题 

6.1.1 对GPU进行性能分析 

6.1.2 帧调试器 

6.1.3 强力测试 

6.1.4 受CPU限制 

6.2 前端瓶颈 

6.2.1 细节级别 

6.2.2 禁用GPU蒙皮 

6.2.3 减少曲面细分 

6.3 后端瓶颈 

6.3.1 填充速率 

6.3.2 内存带宽 

6.3.3 关于VRAM限制 

6.4 照明和阴影 

6.4.1 正向渲染 

6.4.2 延迟着色 

6.4.3 顶点照明着色 

6.4.4 实时阴影 

6.4.5 照明优化 

6.5 为移动设备优化图形 

6.5.1 尽量减少绘制调用 

6.5.2 尽量减少材质数量 

6.5.3 最小化纹理大小和材质数量 

6.5.4 使用正方形和2的幂纹理 

6.5.5 在着色器中使用最低精确度格式 

6.5.6 避免进行Alpha测试 

6.6 小结 

# 第7章 精通内存管理 

7.1 关于Mono平台 

7.1.1 编译过程 

7.1.2 手动JIT编译 

7.2 内存使用优化 

7.2.1 关于Unity内存域 

7.2.2 值类型和引用类型 

7.2.3 数据布局的重要性 

7.2.4 关于Unity API 

7.2.5 关于foreach循环 

7.2.6 协程 

7.2.7 闭包 

7.2.8 关于.NET库函数 

7.2.9 临时工作缓冲区 

7.2.10 对象池 

7.3 预制件池 

7.3.1 可池化的组件 

7.3.2 预制件池系统

7.3.3 预制件池 

7.3.4 对象生成 

7.3.5 预生成实例

7.3.6 对象取消生成 

7.3.7 预制件池测试 

7.3.8 预制件池和场景加载 

7.3.9 预制件池小结 

7.4 关于Mono和Unity的未来 

7.5 小结 

第8章 提示和技巧 

8.1 编辑器热键提示 

8.1.1 和GameObject有关的热键 

8.1.2 场景视图 

8.1.3 数组 

8.1.4 接口 

8.1.5 其他 

8.2 编辑器界面提示 

8.2.1 常规提示 

8.2.2 检查器视图 

8.2.3 项目视图 

8.2.4 分层结构视图 

8.2.5 场景和游戏视图

8.2.6 播放模式 

8.3 脚本编写技巧 

8.3.1 常规技巧 

8.3.2 属性 

8.3.3 记录日志 

8.3.4 有用的链接 

8.4 自定义编辑器/菜单提示 

8.5 外部提示 

8.6 小结 