第1章 检测性能问题 1

1.1 关于Unity Profiler 1

1.1.1 启动Profiler 2

1.1.2 Profiler窗口 6

1.2 性能分析的最佳方法 11

1.2.1 验证场景中是否存在目标脚本 12

1.2.2 验证脚本在场景中出现的次数 13

1.2.3 尽量减少对正在进行的代码的更改 14

1.2.4 最小化内部干扰 14

1.2.5 最小化外部干扰 15

1.3 代码段的目标性能分析 16

1.3.1 关于Profiler的脚本控制 16

1.3.2 自定义CPU性能分析 18

1.4 保存和加载Profiler数据 22

1.4.1 保存Profiler数据 22

1.4.2 加载Profiler数据 26

1.5 关于性能优化和分析的最终思路 29

1.5.1 了解Profiler 30

1.5.2 减少噪声 30

1.5.3 聚焦问题 31

1.6 小结 31

第2章 脚本编写策略 33

2.1 缓存组件引用 33

2.2 使用最快的方法获取组件 34

2.3 删除空的回调声明 37

2.4 在运行时避免使用Find()和SendMessage()方法 39

2.4.1 静态类 41

2.4.2 单例组件 42

2.4.3 分配对现有对象的引用 46

2.4.4 全局消息系统 48

2.5 禁用未使用的脚本和对象 58

2.5.1 按可见性禁用对象 58

2.5.2 按距离禁用对象 59

2.6 考虑使用距离平方值 60

2.7 避免从GameObject中检索字符串属性 61

2.8 更新和协程问题 63

2.9 考虑缓存Transform值的更改 67

2.10 更快的GameObject空引用检查 68

2.11 小结 69

第3章 批处理的好处 71

3.1 绘制调用 71

3.2 材质和着色器 73

3.3 动态批处理 76

3.3.1 顶点属性 77

3.3.2 均匀缩放 77

3.3.3 动态批处理小结 78

3.4 静态批处理 79

3.4.1 静态标志 79

3.4.2 内存需求 80

3.4.3 材质引用 80

3.4.4 静态批处理注意事项 81

3.4.5 静态批处理小结 82

3.5 小结 82

第4章 快速启动艺术资产 85

4.1 音频 85

4.1.1 加载音频文件 86

4.1.2 编码格式和质量等级 88

4.1.3 音频性能增强 89

4.2 纹理文件 93

4.2.1 压缩格式 94

4.2.2 纹理性能增强 95

4.3 网格和动画文件 103

4.3.1 减少多边形数量 103

4.3.2 仅导入/计算所需内容 104

4.3.3 考虑烘焙动画 105

4.3.4 让Unity优化网格 105

4.3.5 合并网格 106

4.4 小结 106

第5章 更快的物理引擎 109

5.1 物理引擎内部 109

5.1.1 物理与时间 110

5.1.2 静态和动态碰撞器 113

5.1.3 碰撞检测 113

5.1.4 碰撞类型 114

5.1.5 碰撞矩阵 115

5.1.6 刚体活动和睡眠状态 116

5.1.7 光线和对象投射 116

5.2 物理性能优化 117

5.2.1 场景设置 117

5.2.2 正确使用静态碰撞器 118

5.2.3 优化碰撞矩阵 119

5.2.4 首选离散碰撞检测 120

5.2.5 修改固定更新频率 121

5.2.6 调整最大允许时间步长 122

5.2.7 最小化投射和包围体检查 122

5.2.8 避免使用复杂的网格碰撞器 124

5.2.9 避免复杂的物理组件 126

5.2.10 让物理对象睡眠 127

5.2.11 修改求解器迭代计数 128

5.2.12 优化布娃娃 129

5.2.13 掌握使用物理引擎的时机 130

5.2.14 考虑升级到Unity 5 131

5.3 小结 131

第6章 动态图形 133

6.1 分析渲染问题 133

6.1.1 对GPU进行性能分析 135

6.1.2 帧调试器 137

6.1.3 强力测试 138

6.1.4 受CPU限制 138

6.2 前端瓶颈 141

6.2.1 细节级别 142

6.2.2 禁用GPU蒙皮 143

6.2.3 减少曲面细分 143

6.3 后端瓶颈 144

6.3.1 填充速率 144

6.3.2 内存带宽 154

6.3.3 关于VRAM限制 157

6.4 照明和阴影 158

6.4.1 正向渲染 159

6.4.2 延迟着色 159

6.4.3 顶点照明着色 160

6.4.4 实时阴影 160

6.4.5 照明优化 160

6.5 为移动设备优化图形 162

6.5.1 尽量减少绘制调用 162

6.5.2 尽量减少材质数量 162

6.5.3 最小化纹理大小和材质数量 163

6.5.4 使用正方形和2的幂纹理 163

6.5.5 在着色器中使用最低精确度格式 163

6.5.6 避免进行Alpha测试 163

6.6 小结 164

第7章 精通内存管理 165

7.1 关于Mono平台 165

7.1.1 编译过程 167

7.1.2 手动JIT编译 168

7.2 内存使用优化 168

7.2.1 关于Unity内存域 169

7.2.2 值类型和引用类型 175

7.2.3 数据布局的重要性 186

7.2.4 关于Unity API 187

7.2.5 关于foreach循环 187

7.2.6 协程 188

7.2.7 闭包 189

7.2.8 关于.NET库函数 189

7.2.9 临时工作缓冲区 190

7.2.10 对象池 190

7.3 预制件池 193

7.3.1 可池化的组件 196

7.3.2 预制件池系统 199

7.3.3 预制件池 201

7.3.4 对象生成 202

7.3.5 预生成实例 203

7.3.6 对象取消生成 205

7.3.7 预制件池测试 205

7.3.8 预制件池和场景加载 207

7.3.9 预制件池小结 207

7.4 关于Mono和Unity的未来 208

7.5 小结 210

第8章 提示和技巧 213

8.1 编辑器热键提示 213

8.1.1 和GameObject有关的热键 213

8.1.2 场景视图 214

8.1.3 数组 214

8.1.4 接口 214

8.1.5 其他 215

8.2 编辑器界面提示 215

8.2.1 常规提示 215

8.2.2 检查器视图 218

8.2.3 项目视图 219

8.2.4 分层结构视图 220

8.2.5 场景和游戏视图 220

8.2.6 播放模式 221

8.3 脚本编写技巧 222

8.3.1 常规技巧 222

8.3.2 属性 223

8.3.3 记录日志 224

8.3.4 有用的链接 225

8.4 自定义编辑器/菜单提示 226

8.5 外部提示 227

8.6 小结 229