# 第1章 检测性能问题 

1. 性能分析的最佳方法
   * 验证场景中是否存在目标脚本

   * 验证脚本在场景中出现的次数
   * 尽量减少对正在进行的代码的更改
   * 最小化内部干扰
   * 最小化外部干扰

# 第2章 脚本编写策略

1. 缓存组件引用

   在Awake、Start等初始化期间缓存组件，不要每次用每次GetComponent

2. 使用最快的方法获取组

   根据测试GetComponent<T>，在所有GetComponent最快

3. 删除空的回调声明

   空的Start、Update方法也是会调用的

4. 在运行时避免使用Find()和SendMessage()方法

   * 静态类

   * 单例组件

   * 分配对现有对象的引用 

   * 全局消息系统 

     像[TinyMessenger](https://github.com/grumpydev/TinyMessenger)等，且Unity的相关的框架基本都有自己的消息系统

5. 禁用未使用的脚本和对象 

   * 按可见性禁用对象 

     视锥体剔除回调方法：OnBecameVisible 和 OnBecameInvisible

   * 按距离禁用对象 

6. 考虑使用距离平方值 

   CPU 比较擅长计算浮点数的乘法，但是要计算平方根却相对比较困难。每次我们要求 Vector3 使用magnitude 属性或 Distance方法计算距离时，都会要求它执行乎方根计算（根据毕达哥拉斯定理）。但是，Vector3 类还提供了一个 sarMagnitude 属性，该属性与 distance相同，不同之处在于它计算的是平方值。这使我们能够进行基本相同的比较检查，而无须包含昂贵的平方根计算，只要我们对要进行比较的值进行平方即可。如果A的magnitude 小于 B的magnitude，则A将小于B。

7. 避免从GameObject中检索字符串属性

   GameObject.tag或者name属性都会引起字符串的复制，从而引起堆内存的分配，但是CompareTag方法不会。

8. 更新和协程选择和优化

9. 考虑缓存Transform值的更改 

   * 变换组件 （Transform Component）仅存储相对于其自身父级的数据。这意味着访问和修改变换组件的 position（位置）、rotation（旋转）和 scale(缩放）属性可能会导致很多意外的矩阵乘法计算，从而通过其父对象的变换为对象生成正确的变换表示形式，所以推荐使用localPosition、localRotation、localScale
   * 设置脏标示，只有需要修改时才修改Transform属性

10. 更快的GameObject空引用检查 

    gameObject == null会调用原生托管桥另一端的方法，推荐使用System.Object. ReferenceEquals (gameObject, null)，当然这个方法产生较好的收益的前提是需要大量的执行gameObject == null此判断。

# 第3章 批处理的好处 

1. 绘制调用 Draw Call

   绘制调用就是从 CPU 发送到GPU 的请求，要求它绘制对象。但是，在可以请求绘制调用之前，需要满足几个重要条件。首先，必须将网格和纹理数据从CPU 内存（RAM推送到GPU 显存 (VRAM)，这通常是在场景初始化期问发生的。接下来，CPU 必须通过配置选项和渲染功能来准备 GPU，这些都是处理作为绘制调用目标的对象所需的。CPU 和GPU 之间的这些通信任务可以通过基本的图形 API 进行，根据我们所针对的平台和某些图形设置，这些图形 API可以是DirectX 或 OpenGL。这些 API 具有许多可以配置的复杂且相互关联的设置、状态量和数据集，并且可用功能会根据我们所操作的硬件设备而发生巨大变化。在渲染单个对象之前，可以配置的大量设置通常会被浓缩为一个称为渲染状态(Render State）的术语。在更改这些渲染状态选项之前，GPU 将为所
   有传入的对象保持相同的渲染状态，并以类似的方式渲染它们。

   **更改谊染状态可能是一个耗时的过程**

2. 动态批处理条件
   * 所有网格实例必须使用相同的材质引用。
   * 仅动态批处理粒子系统和网格渲染器。蒙皮的网格渲染器（用于动画角色）和所有其他可渲染组件类型无法批处理。
   * 着色器使用的顶点属性总数必须不超过 900。
   * 所有网格实例都应使用均匀的缩放比例，或者所有网格都应使用不均匀的缩放比例，但不能两者兼有。
   * 材质的着色器不应取决于多通道。
   * 网格实例不得接收实时阴影。
   * 在一些联合小组会议上还揭示了若干不成文的要求：
     * 每个批处理限制为 300个网格。
     * 整个批处理中的索引不得超过 32000个网格。

3. 动态批处理应用场景
   * 一片大森林，到处都是岩石、树木和灌木丛。
   * 建筑物、工厂或宇宙空间站，场景中有许多常见元素 （如计算机、管道等）。
   * 游戏中包含许多具有简单几何形状的动态非动画对象和粒子效果（想象一下《几何大战》这样的游戏）。

4. 静态批处理条件
   * 网格必须标记为 Static(静态）
   * 必须为静态批处理的每个网格留出额外的内存，即两倍内存换渲染时间。
   * 网格实例可以来自任何源网格，但是它们必须共享相同的材质。

5. 静态批处理注意事项 
   * 节省的绘制调用数无法立即从 Stats（统计）窗口中看到，必须等到运行时。
   * 静态对象不应在运行时引入场景。
   * 静态批处理的网格无法从其原始变换移动。
   * 如果有任何一个静态批处理的网格是可见的，则整个组都将被渲染。

# 第4章 快速启动艺术资产 

## 一、音频 

**Load Type（加载类型）：**

* Decompress On Load（载入时解压缩）

  可压缩磁盘上的文件以节省空间，并在首次加载时将其解压缩到内存中，这是加载音频文件的标准方法，应在大多数情况下使用。

* Compressed In Memory（压缩在内存中）

  在加载时将压缩文件直按加载到内存中，在运行时期间，当需要播放时才对其进行解压缩。播放剪辑时，这将牺牲运行时 CPU,但会提高加载速度并减少运行时的内存消耗。因此，此选项最适合用于经常使用的非常大的音频文件，或者如果程序的内存消耗成为瓶颈，而我们愿意牺牲一些 CPU 周期来播放音频剪辑，则也可以选择此选项。

* Streaming(流媒体）。


  它可以通过逐步将文件推入一个小缓冲区，在运行时即时加载、解码和搔放文件。此方法对于特定的音频剪辑将使用最少的内存，并使用最大的运行时 CPU。这带来计后果此使用将导致大量的内存和运行时 CPU 开销。因此，此选项最适合定期播放目秀然气其他实例重種的单实例音场剪辑。也就是说，该设置最活谷在场系的整个生命周開中都需要播放的背景音乐和环境声音效果中使用。

**编码格式和质量等级** 

* Compressed(压缩格式)

  与Compressed格式一起使用的压缩算法将取决于它所针对的平台。例如，独立应用程序、WebGL 和其他非移动平台将使用 Ogg-Vorbis 进行压缩，而移动平合则多使用MPEG-3 (MP3）格式。

* PCM.

  PCM格式是无损且未压縮的音场格式，提供了与橫拟音频的近似。它以较大的文件量换取更高的音频质量，并且最适合用于非常短的声音效果，这些效果要求非常清晰，否则任何压缩都会使体验失真。

* ADPCM.

  ADPCM 格式在大小和 CPU 消耗方面都比 PCM 高效得多，但是压缩会产生大量噪声。如果我们的音效是短暂而混乱的，例如爆炸、碰撞和撞击声，那么在其中夹杂这样的噪声显然没有任何问题，听众将完全感受不到。

*最后，Compressed 格式产生的文件要比 PCM 格式小，而声音质量也更低（但是它的质量比 ADPCM 要好得多），但会占用额外的运行时 CPU 使用率。在大多数情况下应使用此格式。此选项使我们可以自定义压缩算法的最终质量级别，以根据需要的文件大小调整质量。使用 Quality（质量）滑块的最佳做法是找到尽可能小的声音质量级别（但不应该让用户注意到质量太差）。要找到每个文件的 “最佳质量级别”，可能需要由用户进行一些实际的测试体验*

**音频性能增强** 

1. 尽量减少活动音频源数量
2. 尽量减少音频剪辑引用
   解决方案是利用 Resourees L.oad0和 ResOurces. UnloadAsset0将音频数据仅在播放时粮道在內存中，然后在不再需要用立即释放它。
3. 为30声音启用强制单声道选项
4. 重新采样以降低频率
5. 考虑所有编码格式
   如果应用程序没有内存和硬盘消耗方面的负担，则 WAV 格式可用于减少运行时的CPU 成本。因为在每次播放期间，该格式解码数据所需的开销较小。同时，如果有空府的CPU 周期，厕可以通过床缩编码格式节省空间。
6. 谨慎使用流媒体
   从磁盘流式传输文件应仅限于大型单实例文件，因为它需要运行时磁盘访问权限，这是我们可以使用的最慢的数据访问形式之一。使用此方法的，分层或过渡的音乐剪辑可能合出现重大问题，此时考虑使用 Resources Loado方法才是明智的。
7. 通过混合器组应用滤镜效果以减少重复
8. 负责任地使用 wwW.audioClip
   Unity 的 www 类可用于通过网络流式传输游戏内容。但是，访问 www 对象的audioClip 属性将在每次调用它时分配一个全新的 Audio Clip 资源，并且它获取资源的方法与其他 www 资源获取方法类似。一且不再需要此资源，则必须使用 Resources.UnloadAsset方法将其释放。丢弃可用(将其设置为 null)不会自动释放资源，因此它将继续消耗内存。有鉴于此，我们应该只通过一次audioClip 属性获得音频剪辑，以获取资源引用，从此以后仅使用该引用，并在不再需要时释放它。
9. 考虑将音频模块文件用作背景音乐
   音频模块（Audio Module）文件也称为音轨模块（Tracker Module），是一种节省大量空间而又不会引起明显质量损失的极好方法。Unity 中支持的文件扩展名是.it、.s3m、.xm和.mod。与常见的 PCM 音频格式不同，后者是作为数据的位流读取的，必须在运行时对其进行解码才能生成特定的声音，而音轨模块则包含许多小的高质量 PCM 采样，并像乐谱一样组织整个音轨，定义播放每个样本的时问、位置、音量、音调以及特殊效果。这可以节省很多的文件量，同时又保持高质量的采样。

## 二、纹理文件 

**压缩格式** 

Texture Type（纹理类型）:

 Compressed （压缩）、16-bit（16 位）和True Color（真彩色)

**纹理性能增强** 

1. 降低纹理文件的大小

2. 聪明地使用 MipMap
  应该禁用 MipMap 功能的其他候选项还包括：

  * 几乎所有 2D 游戏申使用的纹理文件。
  * 图形用户界面 （GUI)纹理。
  * 总是在相机附近渲染的网格、精灵和粒子效果的纹理示例包括播放器角色本身、它们持有或携带的任何对象以及始终围绕播放器居中的任何粒子效果。

3. 从外部管理分辦率的降低
   为了使平台自身变得尽可能易用，Unity 做出了不懈的努力，其中就包括允许开发人员将外部工具中的项目文件（例如 PSD 和TIFF 文件）放置到项目工作区中。这些外部文件通常是文件量很大并且分成多个图层的图片。Unity 会根据文件的内容自动生成一个纹理文件供引擎的其余部分使用，这非常方便，因为我们只需要通过 Source Control(源文件控制）维护该文件的单个副本，并且当外部源文件更新时。Unity 副本也会自动更新。
   问题在于，Unity 的自动纹理生成和压缩技术从这些文件引入的**混叠 (Aliasing)**可能不如我们用来生成此类文件的工具（如 Adobe Photoshop 或 Gimp）那么强大和有效。Unity 可能会通过混叠来引入伪像 (Artefact），我们可能会养成习惯，即导入比所需分辨率更高的图像文件，以保持预期的质量水平。但是，如果首先通过外部应用程序缩小图像的比例，则泥叠现象可能会少很多。在这种情况下，就可能以较低的分辦率达到可接受的质量水平，同时消耗更少的总体磁盘和内存空间。
   我们可以避免由于习惯而在 Unity 项日中使用PSD 和 TIFF 文件(将它们存储在其他位置，并将降低分辨率之后的版本导入 Unity中），或者只是执行一些偶尔的测试以确你不会浪费文件大小、内存和 GPU 显存带宽 （未使用比所需分辦率更高的文件）。如果开发人员愿意花时间比较不同的降低分辦率的版本，那么这虽然会使得在项目文件管理上的便利性降低，但是却可以为某些纹理节省大量成本。

4. 调整各向异性过滤水平
   各向异性过滤 （Anisotropic Filtering）是一项功能，当以非常浅的（倾斜）角度查看纹理时，可以提高纹理的图像质量。图4-4 所示的屏幕截图显示了在己应用和末应用各向异性过滤的情況下道路上绘制线条的经典示例。如果不使用各向异性过滤，则绘制的线条离相机越远，它们的线条就会变得模糊和失真，而应用了 “各向异性过滤”的视图则会使这些线条更加清晰明了。
   可以使用 Aniso Level（各向异性过滤级别）设置对每个纹理手动修改应用于纹理的各向异性过滤的强度，也可以使用 Quality Settings （质量设置）中的 Anisotropic Textures(各向异性纹理〉选项来全局启用/禁用该功能。就像 MipMap一样，这种效果可能代价高昂，有时甚至是不必要的。如果场景中有可以确定永远不会以倾斜角度查看的纹理（例如远处的背景精灵和粒子效果纹理）则可以安全地禁用各向异性过滤以节省一些运行时开销。开发人员还可以考虑根据每个纹理调整各向异性过滤效果的强度，以我到质量和性能之间的平衡点

5. 考虑使用纹理集
   纹理集 （Adasing）是将许多较小的孤立的纹理组合成一个大的纹理文件的技术，目的是最大程度地减少材质的数量，从而相应地减少绘制调用(详见本书3.1节“绘制调用”和3.3节“动态批处理”）。从概念上讲，该技术与第了 章“批处理的好处”中介绍过的最小化材质使用量的方法非常相似。

   纹理集的缺点主要在于开发时间和工作流程成本。要利用纹理集来改造现有项目，需要进行大量的工作，而要弄清楚是否值得进行这项工作可能同样需要大量的工作。此外，我们还需要提防生成对于目标平台而言太大的纹理集文件。

   某些设备〈特别是移动设备）对纹理的大小有相对较严格的限制，因为它需要将其拉到 GPU 的最低显存缓存中。如果纹理集太大，则必须将其分解为较小的纹理，以适合目标显存空间。如果渲染器每隔一次绘制调用就需要图集的不同部分中的纹理，那么不仅会造成很多缓存未命中，而且由于纹理不断从显存（VRAM)和低级缓存拉出，可能会出现显存带宽的阻塞。
   因此，纹理集显然不是完美的解决方案。如果不清楚是否会带来性能优势，那么我们应该注意不要在其实现上浪费太多时间。
   一般来说，我们应该从项目开始就尝试将纹理集应用到中高质量的手机游戏中，并注意不要逾越目标平台对于纹理的限制，然后根据需要对每个平台和每个设备进行调整。另一方面，最简单的手机游戏极有可能在不需要任何纹理集的情况下运行。同时，仅当绘制调用次数超过合理的硬件预期时，我们才应考虑将纹理集应用于高质量的台式机游戏，因为我们希望许多纹理都可以保持高分辨率以实现最高质量。低质量的台式机游戏应该可以避免纹理集，因为绘制调用不太可能成为最大的瓶颈。
   当然，无论产品是什么，如果受到绘制调用的 CPU 限制，并且在己经穷尽了许多替代技术的情况下也无法解决，那么纹理集将是下一个实现的最佳技术，因为如果使用得当，它可以节省大量的绘制调用。

6. 调整非正方形纹理的压缩率
   不建议将非正方形和/或非 2的幂 (Non-Power-Of-Two， NPOT）的纹理导入应用程序中，因为 GPU 通常会要求推送的纹理为正方形，而非2的幂的大小会导致不必要的工作负载（需要处理格式错误的图像纹理大小）。Unity 将自动调整纹理并添加额外的空自空间，以适应 GPU 期望的形状因子，这将导致额外的内存带宽成本，将本质上无用的数据推送至 GPU。

7. 稀疏线理 
   稀疏线理 (Sparse Texture） 称为巨大纹理（Meea-Textures）或平铺纹理（Tiled-Textures ，它提供了一种在运行时有效地从磁盘流式传输纹理数据的方法。相对而音，如果CPU 以秒为单位执行额作，则磁盘将以天为单位进行操作。因此，通常的建议息，成不惜_切代价避免在游戏过程中进行硬盘访问，因为任何此类技术都有可能道成破盘访问量超过可用量的风险，从而导致应用程序停止运行。

   但是，稀疏纹理则打破了这一规则，并提供了一些有趣的性能节省技术。稀疏线理的目的是将许多纹理组合成一个巨大的纹理文件，该文件太大而无法作为单个纹理文件加载到图形内存中。除了包含纹理的文件非常大（例如，分辦空为 32768×32768）并且包含相当多的细节 （每个像素32位）之外，这与纹理集的概念是类似的。这个思路是通行动态地手动选择纹理的小部分来 节省大量的运行时内存和内存带宽，并在游戏中需要它们之前将它们从磁盘中拉出。此技术的主要成本是文件大小要求（例如，在上述示例分辨率为 32768×32768 的情况下，文件将占用 4 GB 的磁盘空间！）。这项技术的其他成本则可以通过大量场景准备工作来克服。

8. 程序材质
   程序材质 (Procedural Maverials）也称为 Substance 村质，是一种在运行时通过将高质量的小型纹理样本与自定义数学公式相结合来生成纹理的方法。程应材质的目的是以初始化期间额外的运行时内存和 CPU 处理为代价，最大程度地减少应用程序的占用空间。

## 三、网格和动画文件 

1. 减少多边形数量 
   * 调整网格压缩
     Unity 为导入的网格文件提供了 4 种不同的 Mesh Compression（网格压缩）设置：Off（关）、Low（低）、Medium（中）和High＜高）。
   * 正确使用“己启用读写”标志
     Read Write Enabled（己启用读写）标志允许在运行时通过脚本或在运行时由 Unity自动对网格进行更改。在内部，这意味着它将原始网格数据保留在内存中，直到要复制它并动态更改为止。禁用此选项后，一旦 Unity 确定了要使用的最终网格，即可从内存中丟弃原始网格数据。
     如果在整个游戏中只使用均匀缩放的网格版本，则禁用此选项将节省运行时内存，因为我们将不再需要原始的网格数据来进一步缩放网格的副本 （顺便说一下，这就是Unity 在动态批处理中，按缩放比例因子组织对象的方式）。因此，Unity 可以尽早丢弃这些不需要的数据，因为直到下一次启动应用程序时，我们再也不需要它了。
     但是，如果网格经常以不同的比例在运行时重新出现，则 Unity 需要将该数据保留在内存中，以便可以更快地重新计算新的网格，因此应启用 Read-Write Enabled（己启用读写）标志。禁用它不仅需要 Unity 重新加载网格数据，还需要同时制作重新缩放后的副本，从而导致潜在的性能问题。
     Unity 会尝试在初始化时检测此设置的正确行为，但是，当在运行时实例化网格并以动态方式缩放网格时，我们必须通过启用此设置来强制解决该问题。这将提高对象的实例化速度，但是会花费一些内存开销，因为原始的网格数据会一直保留。

2. 仅导入/计算所需内容 

   这似乎是另一个明显的建议，但是网格不仅包含顶点位置数据。网格中可能还有着色器不需要的 Normals（法线）和Tangents（切线），或者也可能自动生成没什么用的Normals（法线）和Tangents（切线）坐标，尤其是在 Smoothing Angle（平滑角度）非常低的情况下。在这些情况下，每个顶点都需要多个法线向量来创建由此产生的多个面的平面阴影样式。

3. 考虑烘焙动画 

4. 让Unity优化网格(Optimize Mesh选项)

5. 合并网格(静态/手动)

# 第5章 更快的物理引擎 

5.1 物理引擎内部 

5.1.1 物理与时间 

5.1.2 静态和动态碰撞器 

5.1.3 碰撞检测 

5.1.4 碰撞类型 

5.1.5 碰撞矩阵 

5.1.6 刚体活动和睡眠状态 

5.1.7 光线和对象投射 

5.2 物理性能优化 

5.2.1 场景设置 

5.2.2 正确使用静态碰撞器 

5.2.3 优化碰撞矩阵 

5.2.4 首选离散碰撞检测 

5.2.5 修改固定更新频率 

5.2.6 调整最大允许时间步长 

5.2.7 最小化投射和包围体检查 

5.2.8 避免使用复杂的网格碰撞器 

5.2.9 避免复杂的物理组件 

5.2.10 让物理对象睡眠 

5.2.11 修改求解器迭代计数 

5.2.12 优化布娃娃 

5.2.13 掌握使用物理引擎的时机 

5.2.14 考虑升级到Unity 5 

5.3 小结 

# 第6章 动态图形 

6.1 分析渲染问题 

6.1.1 对GPU进行性能分析 

6.1.2 帧调试器 

6.1.3 强力测试 

6.1.4 受CPU限制 

6.2 前端瓶颈 

6.2.1 细节级别 

6.2.2 禁用GPU蒙皮 

6.2.3 减少曲面细分 

6.3 后端瓶颈 

6.3.1 填充速率 

6.3.2 内存带宽 

6.3.3 关于VRAM限制 

6.4 照明和阴影 

6.4.1 正向渲染 

6.4.2 延迟着色 

6.4.3 顶点照明着色 

6.4.4 实时阴影 

6.4.5 照明优化 

6.5 为移动设备优化图形 

6.5.1 尽量减少绘制调用 

6.5.2 尽量减少材质数量 

6.5.3 最小化纹理大小和材质数量 

6.5.4 使用正方形和2的幂纹理 

6.5.5 在着色器中使用最低精确度格式 

6.5.6 避免进行Alpha测试 

6.6 小结 

# 第7章 精通内存管理 

7.1 关于Mono平台 

7.1.1 编译过程 

7.1.2 手动JIT编译 

7.2 内存使用优化 

7.2.1 关于Unity内存域 

7.2.2 值类型和引用类型 

7.2.3 数据布局的重要性 

7.2.4 关于Unity API 

7.2.5 关于foreach循环 

7.2.6 协程 

7.2.7 闭包 

7.2.8 关于.NET库函数 

7.2.9 临时工作缓冲区 

7.2.10 对象池 

7.3 预制件池 

7.3.1 可池化的组件 

7.3.2 预制件池系统

7.3.3 预制件池 

7.3.4 对象生成 

7.3.5 预生成实例

7.3.6 对象取消生成 

7.3.7 预制件池测试 

7.3.8 预制件池和场景加载 

7.3.9 预制件池小结 

7.4 关于Mono和Unity的未来 

7.5 小结 

第8章 提示和技巧 

8.1 编辑器热键提示 

8.1.1 和GameObject有关的热键 

8.1.2 场景视图 

8.1.3 数组 

8.1.4 接口 

8.1.5 其他 

8.2 编辑器界面提示 

8.2.1 常规提示 

8.2.2 检查器视图 

8.2.3 项目视图 

8.2.4 分层结构视图 

8.2.5 场景和游戏视图

8.2.6 播放模式 

8.3 脚本编写技巧 

8.3.1 常规技巧 

8.3.2 属性 

8.3.3 记录日志 

8.3.4 有用的链接 

8.4 自定义编辑器/菜单提示 

8.5 外部提示 

8.6 小结 