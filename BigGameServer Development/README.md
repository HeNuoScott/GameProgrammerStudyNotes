# 百万在线---大型游戏服务端开发

# 第一部分　学以致用

## 第1章　从角色走路说起

1. 分布式程序要处理很多异常情况。如果程序部署在不同物理机 上，连接不太稳定，需要处理好断线重连、断线期间的消息重发，以 及断线后进程间状态不一致的问题。图1-16展示的是因网络不畅通导 致的异常情形，假如客户端A的玩家向客户端B的玩家购买道具，消息 需要通过程序C中转，因程序A和程序C之间的网络连接出现异常，出现 了客户端B的玩家被扣除了道具，客户端A的玩家却没得到道具的情 况。程序A与程序C的网络连接异常，游戏功能受到了影响，就算一段 时间后重新连接上，两个进程的状态也可能会不一致。

   一致性问题是分布式系统的一大难题，在游戏业务中，开发者一 般会把一致性问题抛给具体业务去处理。对于图1-16所示的异常情况，需要给每个交易赋予唯一编号。程序C除了转发消息，还需要记录 程序A对每个交易的执行状态，如果转发失败，程序C要在稍后重发交易消息，直到程序A成功执行。而程序A也需要记录每个交易的状态， 如果某个交易已经成功执行，则不再响应程序C发来的消息，避免重复 添加道具。

   <img src="./截屏2023-02-27 22.17.27.png" style="zoom:25%;" />

   另外，管理数百台物理机、成百上千个程序也不容易，第一，物理机多了，某一台出故障的可能性很大;第二，开启或关闭全部程序要花费很长时间。

1. Actor模型由来已久。早在1973年，Carl Hewitt提出了Actor并发 计算的理论模型;1991年爱立信推出的编程语言Erlang将Actor模型融入语言里，并应用在通信领域里。2009年前后，珠三角的一些游戏公 司(四三九九、菲音、明朝网络)开始大规模地将Erlang语言应用于 游戏领域。2012年前后，云风(吴云洋的网名)开源了C语言Actor模 型框架Skynet，并称之为游戏服务端引擎，且将其应用在不少商业游 戏上。

1. Actor模型的理念——万物皆Actor，它是更进一步的面向对象， 即把世间万物都当作Actor对象。Actor可以代表一个角色、一只动物，也可以代表整个游戏场景，图1-26展示的是用Actor模型抽象的一 个游戏世界，方括号代表Actor的类型，id代表Actor的标识，中间文 本代表名称。

   <img src="./截屏2023-02-27 22.23.12.png" style="zoom:25%;" />

   4. 为什么说Actor模型适用于游戏开发呢?

      回顾1.4.3节的多进程程序，从某种程度上说，Actor模型和传统 的多进程服务端结构有很多相似之处。不同的是，一个操作系统进程 会占用很多的系统资源，按照1.5.3节的分析，进程不仅会占用较多的 内存，操作系统在切换进程(线程)时也会占用较多的CPU时间，一台 物理机只能运行几百个进程，这会限制游戏的业务分割。

## 第2章　Skynet入门精要

1. Skynet是一套历经商业游戏验证的游戏服务端引擎。策略类游戏 《三国志·战略版》、第一人称射击游戏《枪战英雄》，它们都使用了Skynet。然而Skynet是一套底层引擎，不能开箱即用。有网友说“没有5年的服务器经验很难驾驭”。

2. 协程的作用

   Skynet服务在收到消息时，会创建一个协程，在协程中会运行消 息处理方法(即用skynet.dispatch设置的回调方法)。这意味着，如 果在消息处理方法中调用阻塞API(如skynet.call、skynet.sleep、 socket.read)，服务不会被卡住(仅仅是处理消息的协程被卡住)， 执行效率得以提高，但程序的执行时序将得不到保证。

## 第3章　案例：《球球大作战》

### 3.1　功能需求

### 3.2　方案设计

### 3.3　搭架子：目录结构和配置

### 3.4　磨刀工：封装易用的API

### 3.5　分布式登录流程

### 3.6　代码实现：gateway

### 3.7　代码实现：login

### 3.8　代码实现：agentmgr

### 3.9　代码实现：nodemgr

### 3.10　代码实现：agent（单机版）

### 3.11　测试登录流程

### 3.12　战斗流程梳理

### 3.13　代码实现：场景服务

### 3.14　代码实现：agent（跨服务器版）

### 3.15　改进

## 第4章　Skynet进阶技法

### 4.1　用“长度信息”解TCP包

### 4.2　用Json序列化协议

### 4.3　用Protobuf高效传输

### 4.4　如何设计游戏数据库

### 4.5　如何关闭服务器

### 4.6　怎样做定时系统

### 4.7　断线重连

# 第二部分　入木三分

## 第5章　你好，C++并发世界

### 5.1　从HelloWorld开始

### 5.2　多核多线程### 

### 5.3　探索C++对象模型

### 5.4　队列与锁

### 5.5　多线程下的对象管理

### 5.6　充分利用CPU

### 5.7　演示程序PingPong

### 5.8　条件变量与唤醒机制

### 5.9　后台运行

## 第6章　图解TCP网络模块

### 6.1　启动网络线程

### 6.2　半小时搞懂Epoll的用法

### 6.3　打开监听端口

### 6.4　网络事件分发

### 6.5　如何安全读写数据

### 6.6　写缓冲区满

## 第7章　嵌入Lua脚本语言

### 7.1　方案设计

### 7.2　嵌入Lua虚拟机

### 7.3　C++调用Lua方法

### 7.4　Lua调用C++函数

### 7.5　Lua版的PingPong

### 7.6　Lua版聊天室

# 第三部分　各个击破

## 第8章　同步算法

### 8.1　同步难题

### 8.2　客户端障眼法

### 8.3　各类同步方案及适用场景

### 8.4　帧同步

### 8.5　AOI算法

### 8.6　可靠UDP

## 第9章　热更新

### 9.1　Skynet热更新

### 9.2　切换进程

### 9.3　动态库

### 9.4　脚本语言

## 第10章　防外挂

### 10.1　不信任客户端

### 10.2　尽可能多的校验

### 10.3　反外挂常用措施

## 第11章　未尽之路

### 11.1　高并发

### 11.2　服务端架构

### 11.3　工程管理