# 第1章 行为——智能移动

本章将从学习某些最有趣的移动算法开始，这些算法基于 Craig Reynolds 和 Ian Millington一起开发的转向行为原则，本章介绍的实用方法是绝大多数用于高级游戏以及其他依赖于移动的算法（比如寻路算法家族）的 AI的基石。

创建行为模板、追赶和逃跑、为物理引擎调整、到达和离开、朝向物体、徘徊、按路径移动、避开agent 、避开墙体、通过权重混合多个行为、通过优先级混合多个行为、射击抛射体、预测抛射体的着地点 、锁定抛射体 、创建跳跃系统 

# 第2章 导航

1. 用深度优先搜索在迷宫中找到出路

   深度优先搜索(DFS)算法是一个适合小内存设备的寻路算法，另一种常见用法是构建迷宫，只对访问和发现的节点列表做一些修改，然而主要的算法还是一样的。

2. 用广度优先搜索在网格中找到最短路径

   广度优先搜索（BFS)算法是另一个用于图遍历的基础技术，目的是用尽可能最少的步骤获取最短路径，并且权衡内存方面的消耗，尤其针对高端主机和计算机的游戏。

3. 用迪杰斯特拉算法找到最短路径

   迪杰斯特拉算法最初的设计目标是解决图的单源最短路径问题。所以，这个算法找到的是从单一起点到各个终点的最低成本的路线。我们将学习如何用两种不同的方式使用这个算法

4. 用A*找到最优路径*

   A*算法可能是路径查找中最常用的技术了，因为它容易实现、效率高，而且还有优化的余地。所以有一些算法把它作为基础并非巧合。另外，A*与迪杰斯特拉算法具有同根性，所以你会发现它们实现上的相似之处。

5. *改进A*算法的内存占用：IDA*

   IDA*是一个叫作选代深化 DFS ( Torative Depening Deptb-First Search） 算法的变种，内存使用量比 A*小，因为它不使用数据结构存储找到的和访问过的节点。

# 第3章 决策制定

3.1　简介 62

3.2　通过决策树做选择 62

3.3　实现有限状态机 65

3.4　改进有限状态机：分层的有限状态机 67

3.5　实现行为树 69

3.6　使用模糊逻辑 71

3.7　用面向目标的行为制定决策 74

3.8　实现黑板架构 76

3.9　尝试Unity的动画状态机 78

# 第4章 新的NavMesh API

4.1　简介 84

4.2　初始化NavMesh开发组件 84

4.3　创建和管理NavMesh，用于多种类型的agent 86

4.4　在运行时创建和更新NavMesh数据 89

4.5　控制NavMesh实例的生命周期 90

4.6　连接多个NavMesh实例 92

4.7　创建动态的带有障碍物的NavMesh 93

4.8　用NavMesh API实现某些行为 94

# 第5章 协作和战术

5.1　简介 97

5.2　管理队形 98

5.3　扩展A*算法用于协作：A* mbush 102

5.4　用高度分析路径点 105

5.5　用覆盖性和可见性分析路径点 106

5.6　自动化创建路径点 107

5.7　将路径点作为示例用于决策制定 110

5.8　实现势力图 111

5.9　用淹没图改进势力图 114

5.10　用卷积滤波器改进势力图 118

5.11　构建战斗循环 120

# 第6章 agent感知

6.1　简介 128

6.2　基于碰撞系统的视觉函数 128

6.3　基于碰撞系统的听觉函数 130

6.4　基于碰撞系统的嗅觉函数 133

6.5　基于图的视觉函数 136

6.6　基于图的听觉函数 138

6.7　基于图的嗅觉函数 140

6.8　在潜行游戏中创建感知 141

# 第7章 棋类游戏和应用的搜索AI

7.1　简介 148

7.2　使用博弈树类 148

7.3　实现Minimax算法 150

7.4　实现Negamax算法 152

7.5　实现AB Negamax算法 154

7.6　实现Negascout算法 156

7.7　实现井字游戏对手 158

7.8　实现跳棋游戏对手 161

7.9　用UCB1实现石头剪刀布AI 171

7.10　实现无悔匹配算法 175

# 第8章 机器学习

8.1　简介 178

8.2　使用N元语法预测器预测行动 178

8.3　改进预测器：分层的N元语法 181

8.4　学习使用朴素贝叶斯分类器 182

8.5　实现强化学习 184

8.6　实现人工神经网络 188

# 第9章 程序化内容生成

9.1　简介 192

9.2　用深度优先搜索创建迷宫 192

9.3　为地下城和群岛实现可构造算法 195

9.4　生成风景 199

9.5　使用N元语法生成内容 201

9.6　用进化算法生成敌人 204

# 第10章 其他

10.1　简介 209

10.2　创建和管理可编写脚本的对象 209

10.3　更好地处理随机数 211

10.4　构建空气曲棍球游戏对手 213

10.5　实现竞速游戏架构 218

10.6　使用橡皮筋系统管理竞速难度 220