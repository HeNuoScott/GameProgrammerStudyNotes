# 第1章 行为——智能移动

本章将从学习某些最有趣的移动算法开始，这些算法基于 Craig Reynolds 和 Ian Millington一起开发的转向行为原则，本章介绍的实用方法是绝大多数用于高级游戏以及其他依赖于移动的算法（比如寻路算法家族）的 AI的基石。

创建行为模板、追赶和逃跑、为物理引擎调整、到达和离开、朝向物体、徘徊、按路径移动、避开agent 、避开墙体、通过权重混合多个行为、通过优先级混合多个行为、射击抛射体、预测抛射体的着地点 、锁定抛射体 、创建跳跃系统 

# 第2章 导航

1. 用深度优先搜索在迷宫中找到出路

   深度优先搜索(DFS)算法是一个适合小内存设备的寻路算法，另一种常见用法是构建迷宫，只对访问和发现的节点列表做一些修改，然而主要的算法还是一样的。

2. 用广度优先搜索在网格中找到最短路径

   广度优先搜索（BFS)算法是另一个用于图遍历的基础技术，目的是用尽可能最少的步骤获取最短路径，并且权衡内存方面的消耗，尤其针对高端主机和计算机的游戏。

3. 用迪杰斯特拉算法找到最短路径

   迪杰斯特拉算法最初的设计目标是解决图的单源最短路径问题。所以，这个算法找到的是从单一起点到各个终点的最低成本的路线。我们将学习如何用两种不同的方式使用这个算法

4. 用A*找到最优路径*

   A*算法可能是路径查找中最常用的技术了，因为它容易实现、效率高，而且还有优化的余地。所以有一些算法把它作为基础并非巧合。另外，A*与迪杰斯特拉算法具有同根性，所以你会发现它们实现上的相似之处。

5. *改进A*算法的内存占用：IDA*

   IDA*是一个叫作选代深化 DFS ( Torative Depening Deptb-First Search） 算法的变种，内存使用量比 A*小，因为它不使用数据结构存储找到的和访问过的节点。

# 第3章 决策制定

1. 通过决策树做选择

   <img src="./IMG_9746.jpeg" alt="IMG_9746" style="zoom:33%;"  align="left"/>

2. 有限状态机

   <img src="./IMG_9747.jpeg" alt="IMG_9747" style="zoom:35%;" align="left"/>

3. 改进有限状态机：分层的有限状态机

   有限状态机可 以通过划分不同层次和不同层级进行改进。原理还是相同的，只是状态还可以有自己的内部有限状态机，让状态更灵活且可以扩展

4. 行为树

   行为树可以看作是其他几个人工智能技术的综合体，比如有限状态机、规划，以及决策树。实际上，行为树与有限状态机有一些相似之处，但不是状态机，而是跨树结构的动作。

5. 使用模糊逻辑

   有时候当我们必领得对灰色区域而不是基于二进制值的区域做出决策时，模糊逻辑可以作为帮助我们解决这种任务的一组数学技术。假如我们正在开发一个自动驾驶程序，两个可用的行动是转向和速度控制，二者都有度的数值范围。决定如何转向，以及以什么速度行驶，是让驾驶员与众不同且可能更聪明的关键。这种类型的灰色区域就是模糊逻辑要帮我们表示和处理的。

# 第4章 新的NavMesh API

在运行时创建和更新NavMesh数据、控制NavMesh实例的生命周期、连接多个NavMesh实例、创建动态的带有障碍物的NavMesh 93

# 第5章 协作和战术

1. 扩展A*算法用于协作：A* mbush 

   A* mbush 算法分析每个agent 的路径然后增加节点的开销，这样一来，当 agent 使用A* 计算其路径时，最好选择一个与其他agent 不同的路径，那样就可以在目标点位中创建埋伏点了。

2. 用高度分析路径点

   我们遍历附近点位的列表，目的是找到最大宽度和最小宽度，然后计算 -1到1范围内的位置值。也可以通过改变此范围以满足游戏的设计，或在公式中颠倒高度的重要性

3. 用覆盖性和可见性分析路径点

   我们创建了一些迭代逻辑，然后开始在路径点周围放置随机数，以检验是否可到达和可命中。之后，我们计算出一个系数以确定质量值。

4. 自动化创建路径点

   我们将 wavpoint 组件分配给图中的每个节点，或者说每个值得作为路径点的节点(因为凝结算法提升了性能）。路径点根据相关性排序(比如狙击高度或有利位置），然后通过凝结检查哪个邻接点是不需要的。自然地，价值少的凝节点留在了最后的计算结果中。

5. 势力图

   势力映射图与一般图的原理相同，因为只有两个额外的参数用于在图上映射势力，所以与基于势力的顶点相同。最关键的部分依赖于势力的计算，而这部分基于 BFS 算法。对于地图上的每个单位，根据半径摊开其势力。当计算出的势力大于顶点原来的阵营时，顶点的阵营就改变了

6. 用淹没图改进势力图

   算法从阵营的位置点开始遍历整个图。根据我们之前的反向减法运算，永远从优先队列中最强的节点开始遍历，直到它接近一个小于 dropOffThreshold 的值才计算结果如果顶点的值大于当前兵力，或如果分配的阵营是相同的，算法还要想办法在不满足条件时避免分配新的阵营。

7. 用卷积滤波器改进势力图

   在每个位置上应用矩阵滤波器之后，创建新的网格与原始网格进行交换。然后，遍历创建的每个位置点（这些位置点作为目标网格)，然后计算这些位置的值，取原始网格的值并对这个值应用矩阵滤波器。要特别注意矩阵滤波器必须是一个奇数平方的数组，才能让算法可以得到我们期待的结果

# 第6章 agent感知

1. 基于碰撞系统的视觉函数

   <img src="./IMG_9748.jpeg" alt="IMG_9748" style="zoom:33%;" />

   碰撞组件在每一顺中检测是否碰撞到场最中的任何游戏对象。我们利用对 Unity的场景图片和引擎的优化，可以专注于如何处理有效的碰撞。检测之后，如果有目标对象在碰撞器的视说范園内，我们就发射一条射线去检测是否真的可见，或者在 agent 与目标之间是否有一堵墙。

2. 基于碰撞系统的听觉函数

   <img src="./IMG_9750.jpeg" alt="IMG_9750" style="zoom:23%;" />

   碰撞触发器帮助记录 agent 列表中指定给发射器的 agent。 声音发射函数根据agent 到发射器的距离，用声音衰减的原理减少声音强度

3. 基于碰撞系统的嗅觉函数

   <img src="./IMG_9751.jpeg" alt="IMG_9751" style="zoom:25%;" />

   我们使用触发式碰撞器的目的是把气味粒子记录到一个 agent 的感知列表中(用一个字典实现)。当一个粒子被添加进来或被移除出去时就计算出气味中心。然而，我们实现了一个西数用于获取这个中心，因为当没有气味粒子被记录时，内部的中,心位置是不变的。

4. 基于图的视觉函数、基于图的听觉函数、基于图的嗅觉函数

   

# 第7章 棋类游戏和应用的搜索AI

1. Minimax算法

   

2. Negamax算法

   

3. AB Negamax算法

   

4. Negascout算法

   

# 第8章 机器学习

1. 使用N元语法预测器预测行动
2. 改进预测器：分层的N元语法
3. 学习使用朴素贝叶斯分类器
4. 实现强化学习
5. 实现人工神经网络

# 第9章 程序化内容生成

1. 用深度优先搜索创建迷宫
2. 为地下城和群岛实现可构造算法
3. 生成风景
4. 使用N元语法生成内容
5. 用进化算法生成敌人

# 第10章 其他

1. 创建和管理可编写脚本的对象
2. 更好地处理随机数
3. 构建空气曲棍球游戏对手 
4. 实现竞速游戏架构
5. 使用橡皮筋系统管理竞速难度