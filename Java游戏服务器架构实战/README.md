第 1章 游戏服务器架构总体设计01
1．1　游戏服务器架构设计的意义　01
1．1．1　良好的架构设计有助于团队协作开发　01
1．1．2　良好的架构设计有助于避免bug 的产生　02
1．1．3　良好的架构设计有助于制定合理的项目开发周期计划　02
1．1．4　良好的架构设计有利于测试　03
1．2　游戏服务器架构分类　03
1．2．1　单体游戏服务器架构　03
1．2．2　分布式游戏服务器架构　05
1．3　游戏服务器架构基本模块　06
1．3．1　网络通信长连接与短连接　06
1．3．2　网关　07
1．3．3　服务消息交互——消息中间件　08
1．3．4　业务处理框架　09
1．3．5　测试模块　11
1．4　本章总结11
第　2章 服务器项目管理——Maven　12
2．1　Eclipse 中配置Maven 工具　12
2．1．1　Maven 下载与配置　12
2．1．2　Maven 环境变量配置　13
2．1．3　Maven 常用命令示例　15
2．2　搭建Maven 仓库中心　16
2．2．1　安装Nexus　16
2．2．2　在Maven 中配置私服　19
2．2．3　添加非开源依赖Jar 包　21
2．3　创建Maven 项目21
2．3．1　创建父项目　22
2．3．2　创建子项目　23
2．4　本章总结23
第3章　数据库选择与安装24
3．1　数据持久化——MongoDB　24
3．1．1　为什么使用MongoDB　24
3．1．2　安装MongoDB　25
3．2　内存型数据库——Redis　28
3．2．1　为什么使用Redis　28
3．2．2　安装Redis　29
3．2．3　使用Redis 缓存需要注意的事项　30
3．3　本章总结32
第4章　游戏服务中心开发33
4．1　游戏服务中心的作用　33
4．1．1　游戏服务中心提供游戏外围服务　33
4．1．2　游戏服务中心方便动态扩展　34
4．2　游戏服务中心开发准备　34
4．2．1　根据需求设计架构　34
4．2．2　Spring Cloud 简介　36
4．2．3　安装Spring Tool 插件　37
4．2．4　添加公共pom 依赖　38
4．3　用户登录注册功能开发　40
4．3．1　创建游戏服务中心项目　41
4．3．2　网络通信数据格式定义　43
4．3．3　添加数据库操作　45
4．3．4　实现登录注册　50
4．3．5　全局异常捕获处理　55
4．3．6　登录注册测试　56
4．3．7　实现角色创建　57
4．3．8　角色创建测试　59
4．4　本章总结60
第5章　Web 服务器网关开发　61
5．1　Consul 服务注册中心　61
5．1．1　Consul 简介　61
5．1．2　安装Consul　62
5．2　Web 服务器网关功能开发　63
5．2．1　Spring Cloud Gateway 简介　63
5．2．2　创建Web 服务器网关项目　64
5．2．3　网关路由信息配置　66
5．2．4　测试Web 服务器网关请求转发　68
5．3　统一验证请求权限　69
5．3．1　在Web 服务器网关进行权限验证的必要性　69
5．3．2　网关全局过滤组件——GlobalFilter　71
5．3．3　GlobalFilter 实现权限验证　72
5．3．4　测试网关权限验证　74
5．4　请求负载均衡　76
5．4．1　负载均衡组件——Spring Cloud Ribbon　76
5．4．2　自定义负载均衡策略　77
5．4．3　负载均衡策略配置　80
5．5　网关流量限制　81
5．5．1　常见的限流算法　81
5．5．2　添加Web 服务器网关限流策略　83
5．5．3　Web 服务限流测试　86
5．6　HTTPS 请求配置　86
5．6．1　HTTPS 简介　86
5．6．2　HTTPS 证书申请　87
5．6．3　网关服务配置HTTPS 证书　89
5．6．4　测试HTTPS 访问　90
5．7　服务错误异常全局捕获　92
5．7．1　默认全局Web 异常捕获　92
5．7．2　自定义全局Web 异常捕获　93
5．7．3　异常捕获测试　95
5．8　本章总结96
第6章　游戏服务器网关开发97
6．1　游戏服务器网关管理　97
6．1．1　游戏服务器网关必须支持动态伸缩　97
6．1．2　游戏服务器网关项目搭建与配置　99
6．1．3　游戏服务器网关信息缓存管理　101
6．1．4　游戏服务器网关负载均衡策略　105
6．1．5　测试游戏服务器网关信息　107
6．2　客户端与游戏服务器网关通信开发　109
6．2．1　客户端项目创建　109
6．2．2　网络通信数据粘包与断包　117
6．2．3　网络通信协议制定　119
6．2．4　客户端消息编码与解码开发　121
6．2．5　游戏服务器网关消息编码与解码开发　124
6．2．6　使用Netty 实现游戏服务器网关长连接服务　127
6．3　请求消息参数与响应消息参数对象化　130
6．3．1　请求与响应消息封装　130
6．3．2　客户端与游戏服务器网关通信测试　137
6．4　消息体对象序列化与反序列化　139
6．4．1　消息体使用JSON 序列化与反序列化　140
6．4．2　消息体使用Protocol Buffers 序列化与反序列化　142
6．5　消息自动分发处理　146
6．5．1　消息自动分发设计　147
6．5．2　消息自动分发开发　148
6．6　网络通信安全　152
6．6．1　连接认证　152
6．6．2　通信协议加密和解密　154
6．6．3　游戏服务器网关流量限制　158
6．7　网络连接管理　159
6．7．1　连接管理　159
6．7．2　连接心跳检测　163
6．7．3　消息幂等处理　167
6．8　本章总结168
第7章　游戏服务器网关与游戏业务服务数据通信169
7．1　游戏服务器网关与游戏业务服务通信定义　169
7．1．1　游戏服务器网关消息转发　169
7．1．2　定义消息通信模型　170
7．1．3　Spring Cloud Bus 消息总线　173
7．1．4　消息总线通信层——Kafka　174
7．1．5　消息总线消息发布订阅测试　178
7．2　游戏服务器网关与游戏业务服务通信实现　178
7．2．1　消息序列化与反序列化实现　179
7．2．2　游戏服务器网关消息负载均衡　181
7．2．3　游戏服务器网关消息转发实现　185
7．2．4　游戏服务器网关监听接收响应消息　189
7．2．5　添加游戏业务服务项目　190
7．2．6　游戏服务接收并响应网关消息　193
7．3　游戏服务器网关与游戏服务通信测试　195
7．4　本章总结197
第8章　游戏业务处理框架开发198
8．1　游戏服务器中的多线程管理　198
8．1．1　线程数量的管理　198
8．1．2　游戏服务线程池分配　200
8．2　Netty 线程池模型　200
8．2．1　Netty 线程模型的核心类　201
8．2．2　获取线程池执行结果　202
8．3　客户端消息处理管理　205
8．3．1　借鉴Netty 的消息处理机制　205
8．3．2　客户端消息事件处理框架模型　209
8．3．3　实现自定义MultithreadEventExecutorGroup　213
8．3．4　实现GameChannel　217
8．3．5　实现GameChannelPipeline　220
8．3．6　实现AbstractGameChannelHandlerContext　222
8．3．7　实现客户端消息处理与消息返回　224
8．3．8　GameChannel 空闲超时处理　228
8．4　不同游戏用户之间的数据交互　236
8．4．1　多线程并发操作数据导致的错误或异常　237
8．4．2　在功能设计上避免用户数据之间的直接交互　239
8．4．3　在架构设计上解决用户数据之间的直接交互　239
8．4．4　GameChannel 事件自动分发处理　243
8．5　本章总结245
第9章　游戏用户数据管理246
9．1　游戏用户数据异步加载　246
9．1．1　加载游戏数据的时机　246
9．1．2　异步加载游戏数据实现　247
9．2　游戏数据持久化到数据库　250
9．2．1　游戏数据持久化方式　250
9．2．2　异步方式持久化数据的并发问题　251
9．2．3　数据定时异步持久化实现　253
9．3　Player 对象的封装与使用　256
9．3．1　直接操作Player 对象的弊端　256
9．3．2　实现Player 对象数据与行为分离　258
9．4　本章总结260
第　10章 RPC 通信设计与实现　261
10．1　游戏模块服务划分　261
10．1．1　游戏服务需不需要微服务化　261
10．1．2　游戏服务模块进程划分规则　263
10．2　RPC 通信实现　264
10．2．1　自定义RPC 设计　264
10．2．2　负载均衡管理　268
10．2．3　创建竞技场服务项目　274
10．2．4　RPC 请求消息的发送与接收　281
10．2．5　RPC 响应消息的发送与接收　290
10．2．6　RPC 请求超时检测　292
10．3　本章总结293
第　11章 事件系统的设计与实现294
11．1　事件系统在服务器开发中的重要性　294
11．1．1　什么是事件系统　294
11．1．2　事件系统可以解耦模块依赖　295
11．1．3　事件系统使代码更容易维护　296
11．2　事件系统的实现　296
11．2．1　自定义基于监听接口的事件系统　297
11．2．2　自定义基于注解的事件系统　299
11．2．3　Spring 事件系统应用304
11．3　根据事件实现的任务系统　306
11．3．1　任务系统需求　307
11．3．2　面向过程的任务系统实现　308
11．3．3　面向对象的事件触发式任务系统实现　309
11．4　本章总结　314
第　12章 游戏服务器自动化测试315
12．1　游戏服务器自动化测试的重要性　315
12．1．1　单元测试使代码更简洁　315
12．1．2　单元测试保证方法的代码正确性　321
12．1．3　自动化测试保证代码重构的安全性　323
12．2　游戏服务器自动化测试的实现　323
12．2．1　TestNG 框架简介　324
12．2．2　Spring Boot 单元测试配置　325
12．2．3　方法单元测试案例实现　329
12．2．4　服务器集成测试实现　336
12．2．5　使用TestNG 配置文件区分不同的测试环境　340
12．3　本章总结342
第　13章 服务器开发实例——世界聊天系统　343
13．1　单服世界聊天系统实现　343
13．1．1　添加客户端命令　344
13．1．2　服务器实现消息转发　348
13．1．3　单服世界聊天测试　349
13．2　分布式世界聊天系统实现　352
13．2．1　分布式世界聊天系统设计　352
13．2．2　创建单独的聊天项目　354
13．2．3　实现聊天消息的发布与转发　356
13．2．4　分布式世界聊天服务测试　359
13．3　本章总结360第 1章 游戏服务器架构总体设计01
1．1　游戏服务器架构设计的意义　01
1．1．1　良好的架构设计有助于团队协作开发　01
1．1．2　良好的架构设计有助于避免bug 的产生　02
1．1．3　良好的架构设计有助于制定合理的项目开发周期计划　02
1．1．4　良好的架构设计有利于测试　03
1．2　游戏服务器架构分类　03
1．2．1　单体游戏服务器架构　03
1．2．2　分布式游戏服务器架构　05
1．3　游戏服务器架构基本模块　06
1．3．1　网络通信长连接与短连接　06
1．3．2　网关　07
1．3．3　服务消息交互——消息中间件　08
1．3．4　业务处理框架　09
1．3．5　测试模块　11
1．4　本章总结11
第　2章 服务器项目管理——Maven　12
2．1　Eclipse 中配置Maven 工具　12
2．1．1　Maven 下载与配置　12
2．1．2　Maven 环境变量配置　13
2．1．3　Maven 常用命令示例　15
2．2　搭建Maven 仓库中心　16
2．2．1　安装Nexus　16
2．2．2　在Maven 中配置私服　19
2．2．3　添加非开源依赖Jar 包　21
2．3　创建Maven 项目21
2．3．1　创建父项目　22
2．3．2　创建子项目　23
2．4　本章总结23
第3章　数据库选择与安装24
3．1　数据持久化——MongoDB　24
3．1．1　为什么使用MongoDB　24
3．1．2　安装MongoDB　25
3．2　内存型数据库——Redis　28
3．2．1　为什么使用Redis　28
3．2．2　安装Redis　29
3．2．3　使用Redis 缓存需要注意的事项　30
3．3　本章总结32
第4章　游戏服务中心开发33
4．1　游戏服务中心的作用　33
4．1．1　游戏服务中心提供游戏外围服务　33
4．1．2　游戏服务中心方便动态扩展　34
4．2　游戏服务中心开发准备　34
4．2．1　根据需求设计架构　34
4．2．2　Spring Cloud 简介　36
4．2．3　安装Spring Tool 插件　37
4．2．4　添加公共pom 依赖　38
4．3　用户登录注册功能开发　40
4．3．1　创建游戏服务中心项目　41
4．3．2　网络通信数据格式定义　43
4．3．3　添加数据库操作　45
4．3．4　实现登录注册　50
4．3．5　全局异常捕获处理　55
4．3．6　登录注册测试　56
4．3．7　实现角色创建　57
4．3．8　角色创建测试　59
4．4　本章总结60
第5章　Web 服务器网关开发　61
5．1　Consul 服务注册中心　61
5．1．1　Consul 简介　61
5．1．2　安装Consul　62
5．2　Web 服务器网关功能开发　63
5．2．1　Spring Cloud Gateway 简介　63
5．2．2　创建Web 服务器网关项目　64
5．2．3　网关路由信息配置　66
5．2．4　测试Web 服务器网关请求转发　68
5．3　统一验证请求权限　69
5．3．1　在Web 服务器网关进行权限验证的必要性　69
5．3．2　网关全局过滤组件——GlobalFilter　71
5．3．3　GlobalFilter 实现权限验证　72
5．3．4　测试网关权限验证　74
5．4　请求负载均衡　76
5．4．1　负载均衡组件——Spring Cloud Ribbon　76
5．4．2　自定义负载均衡策略　77
5．4．3　负载均衡策略配置　80
5．5　网关流量限制　81
5．5．1　常见的限流算法　81
5．5．2　添加Web 服务器网关限流策略　83
5．5．3　Web 服务限流测试　86
5．6　HTTPS 请求配置　86
5．6．1　HTTPS 简介　86
5．6．2　HTTPS 证书申请　87
5．6．3　网关服务配置HTTPS 证书　89
5．6．4　测试HTTPS 访问　90
5．7　服务错误异常全局捕获　92
5．7．1　默认全局Web 异常捕获　92
5．7．2　自定义全局Web 异常捕获　93
5．7．3　异常捕获测试　95
5．8　本章总结96
第6章　游戏服务器网关开发97
6．1　游戏服务器网关管理　97
6．1．1　游戏服务器网关必须支持动态伸缩　97
6．1．2　游戏服务器网关项目搭建与配置　99
6．1．3　游戏服务器网关信息缓存管理　101
6．1．4　游戏服务器网关负载均衡策略　105
6．1．5　测试游戏服务器网关信息　107
6．2　客户端与游戏服务器网关通信开发　109
6．2．1　客户端项目创建　109
6．2．2　网络通信数据粘包与断包　117
6．2．3　网络通信协议制定　119
6．2．4　客户端消息编码与解码开发　121
6．2．5　游戏服务器网关消息编码与解码开发　124
6．2．6　使用Netty 实现游戏服务器网关长连接服务　127
6．3　请求消息参数与响应消息参数对象化　130
6．3．1　请求与响应消息封装　130
6．3．2　客户端与游戏服务器网关通信测试　137
6．4　消息体对象序列化与反序列化　139
6．4．1　消息体使用JSON 序列化与反序列化　140
6．4．2　消息体使用Protocol Buffers 序列化与反序列化　142
6．5　消息自动分发处理　146
6．5．1　消息自动分发设计　147
6．5．2　消息自动分发开发　148
6．6　网络通信安全　152
6．6．1　连接认证　152
6．6．2　通信协议加密和解密　154
6．6．3　游戏服务器网关流量限制　158
6．7　网络连接管理　159
6．7．1　连接管理　159
6．7．2　连接心跳检测　163
6．7．3　消息幂等处理　167
6．8　本章总结168
第7章　游戏服务器网关与游戏业务服务数据通信169
7．1　游戏服务器网关与游戏业务服务通信定义　169
7．1．1　游戏服务器网关消息转发　169
7．1．2　定义消息通信模型　170
7．1．3　Spring Cloud Bus 消息总线　173
7．1．4　消息总线通信层——Kafka　174
7．1．5　消息总线消息发布订阅测试　178
7．2　游戏服务器网关与游戏业务服务通信实现　178
7．2．1　消息序列化与反序列化实现　179
7．2．2　游戏服务器网关消息负载均衡　181
7．2．3　游戏服务器网关消息转发实现　185
7．2．4　游戏服务器网关监听接收响应消息　189
7．2．5　添加游戏业务服务项目　190
7．2．6　游戏服务接收并响应网关消息　193
7．3　游戏服务器网关与游戏服务通信测试　195
7．4　本章总结197
第8章　游戏业务处理框架开发198
8．1　游戏服务器中的多线程管理　198
8．1．1　线程数量的管理　198
8．1．2　游戏服务线程池分配　200
8．2　Netty 线程池模型　200
8．2．1　Netty 线程模型的核心类　201
8．2．2　获取线程池执行结果　202
8．3　客户端消息处理管理　205
8．3．1　借鉴Netty 的消息处理机制　205
8．3．2　客户端消息事件处理框架模型　209
8．3．3　实现自定义MultithreadEventExecutorGroup　213
8．3．4　实现GameChannel　217
8．3．5　实现GameChannelPipeline　220
8．3．6　实现AbstractGameChannelHandlerContext　222
8．3．7　实现客户端消息处理与消息返回　224
8．3．8　GameChannel 空闲超时处理　228
8．4　不同游戏用户之间的数据交互　236
8．4．1　多线程并发操作数据导致的错误或异常　237
8．4．2　在功能设计上避免用户数据之间的直接交互　239
8．4．3　在架构设计上解决用户数据之间的直接交互　239
8．4．4　GameChannel 事件自动分发处理　243
8．5　本章总结245
第9章　游戏用户数据管理246
9．1　游戏用户数据异步加载　246
9．1．1　加载游戏数据的时机　246
9．1．2　异步加载游戏数据实现　247
9．2　游戏数据持久化到数据库　250
9．2．1　游戏数据持久化方式　250
9．2．2　异步方式持久化数据的并发问题　251
9．2．3　数据定时异步持久化实现　253
9．3　Player 对象的封装与使用　256
9．3．1　直接操作Player 对象的弊端　256
9．3．2　实现Player 对象数据与行为分离　258
9．4　本章总结260
第　10章 RPC 通信设计与实现　261
10．1　游戏模块服务划分　261
10．1．1　游戏服务需不需要微服务化　261
10．1．2　游戏服务模块进程划分规则　263
10．2　RPC 通信实现　264
10．2．1　自定义RPC 设计　264
10．2．2　负载均衡管理　268
10．2．3　创建竞技场服务项目　274
10．2．4　RPC 请求消息的发送与接收　281
10．2．5　RPC 响应消息的发送与接收　290
10．2．6　RPC 请求超时检测　292
10．3　本章总结293
第　11章 事件系统的设计与实现294
11．1　事件系统在服务器开发中的重要性　294
11．1．1　什么是事件系统　294
11．1．2　事件系统可以解耦模块依赖　295
11．1．3　事件系统使代码更容易维护　296
11．2　事件系统的实现　296
11．2．1　自定义基于监听接口的事件系统　297
11．2．2　自定义基于注解的事件系统　299
11．2．3　Spring 事件系统应用304
11．3　根据事件实现的任务系统　306
11．3．1　任务系统需求　307
11．3．2　面向过程的任务系统实现　308
11．3．3　面向对象的事件触发式任务系统实现　309
11．4　本章总结　314
第　12章 游戏服务器自动化测试315
12．1　游戏服务器自动化测试的重要性　315
12．1．1　单元测试使代码更简洁　315
12．1．2　单元测试保证方法的代码正确性　321
12．1．3　自动化测试保证代码重构的安全性　323
12．2　游戏服务器自动化测试的实现　323
12．2．1　TestNG 框架简介　324
12．2．2　Spring Boot 单元测试配置　325
12．2．3　方法单元测试案例实现　329
12．2．4　服务器集成测试实现　336
12．2．5　使用TestNG 配置文件区分不同的测试环境　340
12．3　本章总结342
第　13章 服务器开发实例——世界聊天系统　343
13．1　单服世界聊天系统实现　343
13．1．1　添加客户端命令　344
13．1．2　服务器实现消息转发　348
13．1．3　单服世界聊天测试　349
13．2　分布式世界聊天系统实现　352
13．2．1　分布式世界聊天系统设计　352
13．2．2　创建单独的聊天项目　354
13．2．3　实现聊天消息的发布与转发　356
13．2．4　分布式世界聊天服务测试　359
13．3　本章总结360
