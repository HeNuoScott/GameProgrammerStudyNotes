# 网络游戏的开端

1. HTTP
2. Socket
3. TCP
4. UDP

# 分身有术：异步和多路复用

1. 异步
2. 状态检测Poll
3. 多路复用Select
4. Select服务端、Select客户端

# 实践出真知：大乱斗游戏

1. 搭建场景：角色类Human、类结构设计、 BaseHuman、角色预设、CtrlHuman、SyncHuman
2. 网络模块 ：委托、 通信协议、消息队列、NetManager类、测试网络模块
3. 进入游戏：Enter协议、创建角色、接收Enter协议、测试Enter协议
4. 服务端如何处理消息：反射机制、消息处理函数、 事件处理、玩家数据、处理Enter协议
5. 玩家列表：List协议、客户端处理、服务端处理、测试
6. 移动同步：Move协议、客户端处理、 服务端处理、测试
7. 玩家离开：Leave协议、客户端处理、服务端处理、测试
8. 攻击动作：Attack协议、播放攻击动作、客户端处理、服务端处理、测试
9. 攻击伤害：Hit协议、客户端处理、服务端处理
10. 角色死亡：Die协议、客户端处理、测试

# 正确收发数据流

1. TCP数据流：系统缓冲区、粘包半包现象、人工重现粘包现象

2. 解决粘包问题的方法：长度信息法、固定长度法、结束符号法
3. 大端小端问题
4. 完整发送数据
5. 不完整发送示例、 如何解决发送不完整问题、ByteArray和Queue、解决线程冲突、为什么要使用队列
6. 高效的接收数据、不足之处、完整的ByteArray、将ByteArray应用到异步程序

# 深入了解TCP，解决暗藏问题

1. 从TCP到铜线：应用层、传输层、网络层、网络接口
2. 数据传输流程：TCP连接的建立、TCP的数据传输、TCP连接的终止
3. 常用TCP参数：ReceiveBufferSize、SendBufferSize、 NoDelay、TTL、ReuseAddress、LingerState
4. Close的恰当时机
5. 异常处理
6. 心跳机制

# 通用客户端网络模块

#### 6.1 网络模块设计

##### 6.1.1 对外接口

##### 6.1.2 内部设计

#### 6.2 网络事件

##### 6.2.1 事件类型

##### 6.2.2 监听列表

##### 6.2.3 分发事件

#### 6.3 连接服务端

##### 6.3.1 Connect

##### 6.3.2 ConnectCallback

##### 6.3.3 测试程序

#### 6.4 关闭连接

##### 6.4.1 isClosing

##### 6.4.2 Close

##### 6.4.3 测试

#### 6.5 Json协议

##### 6.5.1 为什么会有协议类

##### 6.5.2 使用JsonUtility

##### 6.5.3 协议格式

##### 6.5.4 协议文件

##### 6.5.5 协议体的编码解码

##### 6.5.6 协议名的编码解码

#### 6.6 发送数据

##### 6.6.1 Send

##### 6.6.2 SendCallback

##### 6.6.3 测试

#### 6.7 消息事件

#### 6.8 接收数据

##### 6.8.1 新的成员

##### 6.8.2 ConnectCallback

##### 6.8.3 ReceiveCallback

##### 6.8.4 OnReceiveData

##### 6.8.5 Update

##### 6.8.6 测试

#### 6.9 心跳机制

##### 6.9.1 PING和PONG协议

##### 6.9.2 成员变量

##### 6.9.3 发送PING协议

##### 6.9.4 监听PONG协议

##### 6.9.5 测试

#### 6.10 Protobuf协议

##### 6.10.1 什么是Protobuf

##### 6.10.2 编写proto文件

##### 6.10.3 生成协议类

##### 6.10.4 导入protobuf-net.dll

##### 6.10.5 编码解码

### 7 通用服务端框架

#### 7.1 服务端架构

##### 7.1.1 总体架构

##### 7.1.2 模块划分

##### 7.1.3 游戏流程

#### 7.2 Json编码解码

##### 7.2.1 添加协议文件

##### 7.2.2 引用System.web.Extensions

##### 7.2.3 修改MsgBase类

##### 7.2.4 测试

#### 7.3 网络模块

##### 7.3.1 整体结构

##### 7.3.2 ClientState

##### 7.3.3 开启监听和多路复用

##### 7.3.4 处理监听消息

##### 7.3.5 处理客户端消息

##### 7.3.6 关闭连接

##### 7.3.7 处理协议

##### 7.3.8 Timer

##### 7.3.9 发送协议

##### 7.3.10 测试

#### 7.4 心跳机制

##### 7.4.1 lastPingTime

##### 7.4.2 时间戳

##### 7.4.3 回应MsgPing协议

##### 7.4.4 超时处理

##### 7.4.5 测试程序

#### 7.5 玩家的数据结构

##### 7.5.1 完整的ClientState

##### 7.5.2 PlayerData

##### 7.5.3 Player

##### 7.5.4 PlayerManager

#### 7.6 配置MySQL数据库

##### 7.6.1 安装并启动MySQL数据库

##### 7.6.2 安装Navicat for MySQL

##### 7.6.3 配置数据表

##### 7.6.4 安装connector

##### 7.6.5 MySQL基础知识

#### 7.7 数据库模块

##### 7.7.1 连接数据库

##### 7.7.2 防止SQL注入

##### 7.7.3 IsAccountExist

##### 7.7.4 Register

##### 7.7.5 CreatePlayer

##### 7.7.6 CheckPassword

##### 7.7.7 GetPlayerData

##### 7.7.8 UpdatePlayerData

#### 7.8 登录注册功能

##### 7.8.1 注册登录协议

##### 7.8.2 记事本协议

##### 7.8.3 注册功能

##### 7.8.4 登录功能

##### 7.8.5 退出功能

##### 7.8.6 获取文本功能

##### 7.8.7 保存文本功能

##### 7.8.8 客户端界面

##### 7.8.9 客户端监听

##### 7.8.10 客户端注册功能

##### 7.8.11 客户端登录功能

##### 7.8.12 客户端记事本功能

##### 7.8.13 测试

### 8 完整大项目《坦克大战》

#### 8.1 《坦克大战》游戏功能

##### 8.1.1 登录注册

##### 8.1.2 房间系统

##### 8.1.3 战斗系统

#### 8.2 坦克模型

##### 8.2.1 导入模型

##### 8.2.2 模型结构

#### 8.3 资源管理器

##### 8.3.1 设计构想

##### 8.3.2 代码实现

##### 8.3.3 测试

#### 8.4 坦克类

##### 8.4.1 设计构想

##### 8.4.2 代码实现

##### 8.4.3 测试

#### 8.5 行走控制

##### 8.5.1 速度参数

##### 8.5.2 移动控制

##### 8.5.3 测试

##### 8.5.4 走在地形上

#### 8.6 坦克爬坡

##### 8.6.1 Unity的物理系统

##### 8.6.2 添加物理组件

##### 8.6.3 测试

#### 8.7 相机跟随

##### 8.7.1 功能需求

##### 8.7.2 数学原理

##### 8.7.3 编写代码

##### 8.7.4 测试

#### 8.8 旋转炮塔

##### 8.8.1 炮塔元素

##### 8.8.2 旋转控制

##### 8.8.3 测试

#### 8.9 发射炮弹

##### 8.9.1 制作炮弹预设

##### 8.9.2 制作爆炸效果

##### 8.9.3 炮弹组件

##### 8.9.4 坦克开炮

##### 8.9.5 测试

#### 8.10 摧毁敌人

##### 8.10.1 坦克的生命值

##### 8.10.2 焚烧特效

##### 8.10.3 坦克被击中处理

##### 8.10.4 炮弹的攻击处理

##### 8.10.5 测试

### 9 UI界面模块

#### 9.1 界面模块的设计

##### 9.1.1 简单的界面调用

##### 9.1.2 通用界面模块

#### 9.2 场景结构

#### 9.3 面板基类BasePanel

##### 9.3.1 设计要点

##### 9.3.2 代码实现

##### 9.3.3 知识点

#### 9.4 界面管理器PanelManager

##### 9.4.1 层级管理

##### 9.4.2 打开面板

##### 9.4.3 关闭面板

#### 9.5 登录面板LoginPanel

##### 9.5.1 导入资源

##### 9.5.2 UI组件

##### 9.5.3 制作面板预设

##### 9.5.4 登录面板类

##### 9.5.5 打开面板

##### 9.5.6 引用UI组件

##### 9.5.7 网络监听

##### 9.5.8 登录和注册按钮

##### 9.5.9 收到登录协议

#### 9.6 注册面板RegisterPanel

##### 9.6.1 制作面板预设

##### 9.6.2 注册面板类

##### 9.6.3 按钮事件

##### 9.6.4 收到注册协议

#### 9.7 提示面板TipPanel

##### 9.7.1 制作面板预设

##### 9.7.2 提示面板类

##### 9.7.3 测试面板

#### 9.8 游戏入口GameMain

##### 9.8.1 设计要点

##### 9.8.2 代码实现

##### 9.8.3 缓存用户名

#### 9.9 功能测试

##### 9.9.1 登录

##### 9.9.2 注册

##### 9.9.3 下线

### 10 游戏大厅和房间

#### 10.1 列表面板预设

##### 10.1.1 整体结构

##### 10.1.2 个人信息栏

##### 10.1.3 操作栏

##### 10.1.4 房间列表栏

##### 10.1.5 Scroll View

##### 10.1.6 列表项Room

#### 10.2 房间面板预设

##### 10.2.1 整体结构

##### 10.2.2 列表栏

##### 10.2.3 列表项Player

##### 10.2.4 控制栏

#### 10.3 协议设计

##### 10.3.1 查询战绩MsgGetAchieve协议

##### 10.3.2 查询房间列表MsgGetRoomList协议

##### 10.3.3 创建房间MsgCreateRoom协议

##### 10.3.4 进入房间MsgEnterRoom协议

##### 10.3.5 查询房间信息MsgGetRoomInfo协议

##### 10.3.6 退出房间MsgLeaveRoom协议

##### 10.3.7 开始战斗MsgStartBattle协议

#### 10.4 列表面板逻辑

##### 10.4.1 面板类

##### 10.4.2 获取部件

##### 10.4.3 网络监听

##### 10.4.4 刷新战绩

##### 10.4.5 刷新房间列表

##### 10.4.6 加入房间

##### 10.4.7 创建房间

##### 10.4.8 刷新按钮

#### 10.5 房间面板逻辑

##### 10.5.1 面板类

##### 10.5.2 获取部件

##### 10.5.3 网络监听

##### 10.5.4 刷新玩家列表

##### 10.5.5 退出房间

##### 10.5.6 开始战斗

#### 10.6 打开列表面板

#### 10.7 服务端玩家数据

##### 10.7.1 存储数据

##### 10.7.2 临时数据

#### 10.8 服务端房间类

##### 10.8.1 管理器和房间类的关系

##### 10.8.2 房间类的设计要点

##### 10.8.3 添加玩家

##### 10.8.4 选择阵营

##### 10.8.5 删除玩家

##### 10.8.6 选择新房主

##### 10.8.7 广播消息

##### 10.8.8 生成房间信息

#### 10.9 服务端房间管理器

##### 10.9.1 数据结构

##### 10.9.2 获取房间

##### 10.9.3 添加房间

##### 10.9.4 删除房间

##### 10.9.5 生成列表信息

#### 10.10 服务端消息处理

##### 10.10.1 查询战绩MsgGetAchieve

##### 10.10.2 查询房间列表MsgGetRoomList

##### 10.10.3 创建房间MsgCreateRoom

##### 10.10.4 进入房间MsgEnterRoom

##### 10.10.5 查询房间信息MsgGetRoomInfo

##### 10.10.6 离开房间MsgLeaveRoom

#### 10.11 玩家事件处理

#### 10.12 测试

### 11 战斗和胜负判定

#### 11.1 协议设计

##### 11.1.1 进入战斗MsgEnterBattle

##### 11.1.2 战斗结果MsgBattleResult

##### 11.1.3 退出战斗MsgLeaveBattle

#### 11.2 坦克

##### 11.2.1 不同阵营的坦克预设

##### 11.2.2 战斗模块

##### 11.2.3 同步坦克SyncTank

##### 11.2.4 坦克的属性

#### 11.3 战斗管理器

##### 11.3.1 设计要点

##### 11.3.2 管理器类

##### 11.3.3 坦克管理

##### 11.3.4 重置战场

##### 11.3.5 开始战斗

##### 11.3.6 产生坦克

##### 11.3.7 战斗结束

##### 11.3.8 玩家离开

#### 11.4 战斗结果面板

##### 11.4.1 面板预设

##### 11.4.2 面板逻辑

#### 11.5 服务端开启战斗

##### 11.5.1 能否开始战斗

##### 11.5.2 定义出生点

##### 11.5.3 坦克信息

##### 11.5.4 开启战斗

##### 11.5.5 消息处理

#### 11.6 服务端胜负判断

##### 11.6.1 是否死亡

##### 11.6.2 胜负决断函数

##### 11.6.3 定时器

##### 11.6.4 Room::Update

#### 11.7 服务端断线处理

#### 11.8 测试

##### 11.8.1 进入战场

##### 11.8.2 离开战场

### 12 同步战斗信息

#### 12.1 同步理论

##### 12.1.1 同步的过程

##### 12.1.2 同步的难题

#### 12.2 状态同步

##### 12.2.1 直接状态同步

##### 12.2.2 跟随算法

##### 12.2.3 预测算法

#### 12.3 帧同步

##### 12.3.1 指令同步

##### 12.3.2 从Update说起

##### 12.3.3 什么是同步帧

##### 12.3.4 指令

##### 12.3.5 指令的执行

#### 12.4 协议设计

##### 12.4.1 位置同步MsgSyncTank

##### 12.4.2 开火MsgFire

##### 12.4.3 击中MsgHit

#### 12.5 发送同步信息

##### 12.5.1 发送位置信息

##### 12.5.2 发送开火信息

##### 12.5.3 发送击中信息

#### 12.6 处理同步信息

##### 12.6.1 协议监听

##### 12.6.2 OnMsgSyncTank

##### 12.6.3 OnMsgFire

##### 12.6.4 OnMsgHit

#### 12.7 同步坦克SyncTank

##### 12.7.1 预测算法的成员变量

##### 12.7.2 移动到预测位置

##### 12.7.3 初始化

##### 12.7.4 更新预测位置

##### 12.7.5 炮弹同步

#### 12.8 服务端消息处理

##### 12.8.1 位置同步MsgSyncTank

##### 12.8.2 开火MsgFire

##### 12.8.3 击中MsgHit

##### 12.8.4 调试

#### 12.9 完善细节

##### 12.9.1 滚动的轮子和履带

##### 12.9.2 灵活操作

##### 12.9.3 准心

##### 12.9.4 自动瞄准

##### 12.9.5 界面和场景优化

##### 12.9.6 战斗面板

##### 12.9.7 击杀提示

12.10 结语
